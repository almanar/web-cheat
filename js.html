<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>js</title>
  <link rel="shortcut icon" type="image/x-icon" href="flower.jpg" />
  <style>
   .border { border:1px solid black; }
   pre {
     border:1px solid black;
     background-color: #EEE;
     padding: 5px;
   }
  </style>
  <script src="assert.js"></script>
  <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
  <script src="/assets/jquery.toc.js"></script>
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  <script>
    $('#toc').toc({
      content: 'div.content',
      headings: 'h1,h2,h3,h4,h5,h6'
    });
  </script>
</head>
<body onload="document.getElementById('onload').innerHTML = 'onload'">
<h1>Javascript Cheatsheet</h1>

<ul data-toc></ul>

<h2>About</h2>

  <p>
    Every script tag in this cheat is HTML escaped and put inside a pre element after its script
    by a script so you can see it. Scripts are styled like this:
  </p>
  <script>
    // Inside script element.
    var a = 1
  </script>
  <p>
    This cheatsheet is designed to work in modern ES5 compliant browsers.
    No effort was made to account for incompatibilities.
  </p>
  <p>
    Content is currently being converted from Js comments to HTML + scripts.
    This explains the remaining huge script blocks with many useful comments.
  </p>

  <h3>Helper methods</h3>

    <p>The following helper methods are used on this cheat:</p>

    <script>
      var previousElement = function() {
        return document.currentScript.previousElementSibling
      }

      var insertBeforeScript = function(elem) {
        document.currentScript.parentNode.insertBefore(elem, document.currentScript)
      }

      var strToElement = function(str) {
        var dummy = document.createElement('div')
        dummy.innerHTML = str
        return dummy.childNodes[0]
      }

      // Make the script elements visible.
      document.addEventListener(
        'DOMContentLoaded',
        function() {
          Array.prototype.slice.call(document.getElementsByTagName('script')).forEach(function(elem) {
            elem.insertAdjacentHTML('afterEnd', '<pre class="prettyprint">'
              + elem.innerHTML.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
              + '</pre>'
            )
          })
        },
        true
      )
    </script>

<h2>Introduction</h2>

  <p>Javascript is a toy language designed to run in a browser.</p>
  <p>
    More recently, it has also been used outside of browsers, often server side, through Node.js.
    This cheat shall consider mostly a world without Node.js: for a Node.js cheat see:
    https://github.com/cirosantilli/nodejs
  </p>
  <p>
    It can be embedded on the HTML given by the server to the browser inside `script` tags.
    It can also be given in separate `.js` files which are then included in the HTML header.
  </p>
  <p>
    One of the goals of Javascript is to restrict what the language can do to prevent malicious attacks.
    Therefore, by design choice Javascript does not allows dangerous operations such as file IO
    (this might be possible soon with: <a href="http://www.w3.org/TR/FileAPI/">the File API</a>)
    Node.js adds such abilities to Javascript through its standard library.
  </p>
  <p>
    Javascript is known for having some weird quirks. CoffeScript, a language that compiles to Javascript
    but behaves more like Ruby, attempts to correct many of those quirks.
  </p>

<h2>#Standards #ECMAScript</h2>

  <p>Official language name: ECMA-262, or ECMAScript.</p>
  <p>Versions are often abbreviated as: ES5, ES6, etc.</p>
  <ul>
    <li>
      <p>6, AKA #harmony</p>
      <p>TODO where is the official draft?</p>
      <p>Expected Dec 2014.</p>
      <p>Good cheat: <a href="https://github.com/lukehoban/es6features">https://github.com/lukehoban/es6features</a></p>
      <p>Promises: <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">http://www.html5rocks.com/en/tutorials/es6/promises/</a></p>
    </li>
    <li>
      <p>5.1, 2011: <a href="http://www.ecma-international.org/ecma-262/5.1/">http://www.ecma-international.org/ecma-262/5.1/</a></p>
      <p>Generally implemented.</p>
      <p>Fully implemented by Google's V8 engine for Chrome and Node.js.</p>
      <p>http://www.ecma-international.org/publications/standards/Ecma-262.htm</p>
    </li>
    <li>v5: 2009</li>
    <li>v4: was aborted</li>
    <li>v3: 1999</li>
  </ul>
  <p>
    ECMAScript does not include objects which browsers add to Javascript such as `document`, `window`, `XMLHttpRequest`,
    although it does furnish some global objects like JSON.
    Such objects are typically specified in separate W3C specs.
  </p>
  <p>
    Browser objects are not directly available to Node.js, including useful ones such as `XMLHttpRequest`.
    Some projects implement the browser interfaces as a Node javascript library, such as
    <a href="https://github.com/driverdan/node-XMLHttpRequest">https://github.com/driverdan/node-XMLHttpRequest</a>
    thus allowing to use such objects in Node.js / browser portable code./
  </p>

<h2>#Detect #version</h2>

  <p>Not possible?! <a href="http://stackoverflow.com/questions/7340726/detect-version-of-javascript">http://stackoverflow.com/questions/7340726/detect-version-of-javascript</a></p>
  <p>People recommend checking for individual features instead.</p>

<h2>#sources</h2>

  <p>Besides the standards, also check out:</p>
  <ul>
    <li>
      Mozilla Developer Network.
      https://developer.mozilla.org
      Lots of examples and comments about the standards and implementation status in other browsers.
    </li>
  </ul>

<h2>#Style</h2>

  <ul>
    <li>
      GitHub: https://github.com/styleguide/javascript
      <ul>
        <li>2 space indent</li>
        <li>no semicolons</li>
      </ul>
    <li>
      Google: http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
      <ul>
        <li>2 space indent</li>
        <li>semicolons</li>
        <li>single quoted strings by default. Easier to include HTML with attributes, which in their style uses double quotes.</li>
      </ul>
    </li>
    <li>
      Airbnb; https://github.com/airbnb/javascript
      <ul>
        <li>semicolons</li>
      </ul>
    </li>
  </ul>

<h2>#Minification</h2>

  <p>Since Javascript is sent to browsers over the network, methods have been developed to make Javascript code smaller:</p>

  <h3>#Compression</h3>

    <p>Compress Javascript with gzip before sending. Notify browser with `Content-Encoding` HTTP header.</p>

  <h3>#Minification</h3>

    <p>Remove unnecessary characters like whitespaces.</p>

  <h3>#Obfuscation</h3>

    <p>
      Rename variables and functions to shorter names, factor things out in ways
      that are shorter but hard for humans to understand.
    </p>

  <h3>#Concatenation</h3>

    <p>Concatenate multiple Js files together.</p>
    <p>
      OK, not really a form of compression, but serves the same purpose: make things faster,
      in this case by reducing the number of HTTP requests.
    </p>
    <p>
      When writing Javascript code, you must be aware that this can happen, and that it may have consequences.
      See for example the Semicolon before IIFE pattern.
    </p>

<h2>#script element</h2>

  <h3>#script element</h3>

    <p>`script` elements can appear either inside the head or of the body.</p>
    <p>
      The most commonly recommended place is load all scripts just before the `body` tag,
      so that the page can load before long scripts do, so it seems more responsive.
    </p>
    <p>
      It is not valid to put scripts after the /body tag, as HTML specifies that only
      comments can be put there.
    </p>

  <h3>#multiple script elements</h3>

    <p>Scripts are executed in the order which they appear on the file.</p>
    <p>head scripts are executed before body ones.</p>
    <p>Definitions from previous scripts blocks are kept for future script blocks:</p>
    <script>
      var i = 1
    </script>
    <script>
      assert_eq(i, 1)
    </script>
    <p>
      Errors and uncaught exceptions (e.g. undefined variables) only stop execution of the current script block:
      future script blocks still execute. There is no way to prevent future script blocks from executing.
    </p>
    <script>
      global_undefined
    </script>

  <h3>#src attribute</h3>

    <p>Source a script from a separate `.js` file.</p>
    <p>In HTML5, the `script` tag *cannot* be self closing because it is neither `void` nor `foreign`.</p>
    <p>
      In HTML5 you cannot have src and a non empty innerHTML:
      http://stackoverflow.com/questions/6528325/what-does-a-script-tag-with-src-and-content-mean
    </p>
    <script src="external.js"></script>
    <script>
      assert_eq(external, 1)
    </script>

    <h3>#async attribute</h3>

      <p>It is possible to run external scripts asynchronously.</p>
      <p>This makes script run other unpredictable.</p>
      <p>Can only be used for external scripts.</p>
      <script src="external.js" async></script>

  <h3>#type attribute</h3>

    <p>Before HTML5 it was mandatory to specify the language of the script as an attribute to the script tag:</p>
    <code>type="text/javascript"</code>
    <p>In HTML5 js became the default, so the attribute is not needed anymore.</p>

  <h3>Close script tag inside Javascript #/scr'+'ipt</h3>

    <p>
      Any HTML tags can be included inside a script element except the closing script tag.
      The HTML parser just reads everything up to that and then passes it to the Js interpreter.
    </p>
    <p>
      A common technique to write a literal &lt;/script&gt; string inside Javascript it to break it up
      with concatenation as `/scr'+'ipt`
    </p>

  <h3>#Strict mode #Use strict</h3>

    <p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode</p>
    <p>ES5.</p>
    <p>Throws exceptions in a bunch of extra smart cases.</p>
    <p>Turn on for entire script element:</p>
    <script>
      'use strict'
      assert_raises(
        function() {
          01
        },
        SyntaxError
      )
    </script>
    <p>Turn on for single function:</p>
    <script>
      assert_raises(
        function() {
          'use strict'
          01
        },
        SyntaxError
      )

      // TODO why passes?
      assert_raises(
        function() {
          'use strict'
          01
        },
        'asdf'
      )

      assert_not_raises(
        function() {
          01
        }
      )
    </script>

<script>
// #exit

  // Stop interpreting the current script block now.

    //exit()

// #semicolon #;

  // Separates statements.

    var i = 1; i = 2;
    assert_eq(i, 2);

  // #ASI

    // Automatic semicolon insertion.

    // In most cases, semicolons are automatically added by the parser at newlines:

      var i = 1
      i = 2
      assert_eq(i, 2)

    // There are a few complex cases however.

    // http://inimino.org/~inimino/blog/javascript_semicolons

    // Operators inhibit ASI to allow programmers to write:

      var i = 1 +
        1
      assert_eq(i, 2)

      var i = 1
        + 1
      assert_eq(i, 2)

    // Because of ASI, many people use a coding style without semicolons,
    // using them only for the only exception: lines that start with parenthesis:

      var i = 1
      ;(assert_eq(i, 1))

    // One notable case where this happens is for IIFE scope preservation.

    // TODO why are semicolons are not required are in single line functions:

      var f = function() { return 0 }
      assert_eq(f(), 0)
      // Instead of:
      var f = function() { return 0; }

    // Advantages of using semicolons:

      // - slightly saner because you don't have to think if it will be added or not automatically,
      //     but only slightly because the no insertion rule is intuitive, except for the parenthesis case.

      // - slightly better for framework concatenation and minification,
      //     but only slightly because good tools should be able to work around that, and the better compression
      //     method is gzipping it anyways.

    // It is a controversial subject which style is better. This is one of the things CoffeScript takes care of.

    // GitHub style says no semicolons. Rationale: http://mislav.uniqpath.com/2010/05/semicolons/

    // Google says semicolons. Rationale: http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Semicolons

// #comments

  // Like C++.

    // Single line.

    /* Multi
      line.
    */

// #case

  // Javascript is case sensitive

    var i = 1
    var I = 2
    assert_eq(i, 1)
    assert_eq(I, 2)
/*
#identifiers

  Identifiers can contain very weird characters.
  http://stackoverflow.com/questions/1661197/valid-characters-for-javascript-variable-names

  The first character is more restricted than the following ones, for example it cannot be a number.

  Some libraries make extensive use of such variables, notably JQuery which uses the dollar sign `$`
  which is an alias for jQuery.

  Make sure you head > meta > UTF-8 if you really want to use non ASCII identifier chars.
*/

  // This is works, but let's not break jQuery shall we:

    //var $ = 1
    //assert_eq($, 1)

    var ᾏ = 1
    assert_eq(ᾏ, 1)

// #operators

  // #tilde operator #~

    // Binary negation.

    // Common application: transform `-1` into `0` on `indexOf` (jQuery `inArray`).

    // Works because number representation is fixed at 2's complement and in that case:

    // - ~-1 == 0
    // - there is no other number such that ~x == 0.

      assert_eq(~-1,  0)
      assert_eq(~ 0, -1)

  // #comma operator

    i = 1, j = 2
    assert_eq(i, 1)
    assert_eq(j, 2)

  // #boolean

// #if

    if (false) {
      assert(false)
    } else {
    }

    if (true) {
    } else {
      assert(false)
    }

  // Like Python, some objects are converted to true, others to false.

  // Only the following are false:

    if (0) {
      assert(false)
    } else {
    }

    if ("") {
      assert(false)
    } else {
    }

    if (null) {
      assert(false)
    } else {
    }

    if (undefined) {
      assert(false)
    } else {
    }

    if (NaN) {
      assert(false)
    } else {
    }

  // All others are true.

    if (-1) {
    } else {
      assert(false)
    }

    if (1) {
    } else {
      assert(false)
    }

    if ("a") {
    } else {
      assert(false)
    }

    if ([]) {
    } else {
      assert(false)
    }

// #for

  // C like:

    var total = 0
    for (var i = 0; i < 3; i++) {
      total += i
    }
    assert_eq(total, 3)

  // For in: iterates over **object properties**!

    var total = 0
    var obj = {'a': 1, 'b': 2}
    for (var x in obj) {
      total += obj[x]
    }
    assert_eq(total, 3)

// #continue

// #break

  // Both have a label and label-less form.

  // Label-less form is the same as C.

  // break:    without label only inside loops, with valid in any code block.
  // continue: with or without label only inside loops.

    var total = 0;
    for (var i = 0; i < 3; i++) {
      if (i == 1)
        continue
      total += i
    }
    assert_eq(total, 2)

  // TODO understand label form. Good examples: http://www.tutorialspoint.com/javascript/javascript_loop_control.htm

// #primitive types #base types #mutable #immutable

  // http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/

  // There are 5 primitive types in Javascript:

  // - undefined
  // - null
  // - boolean
  // - string
  // - number

  // Everything else is an object.

  // Of the primitive types, `boolean`, `string` and `number` have corresponding Object wrappers: Boolean, String.

  // This is so to allow to simulate the property syntax to those primitive types.

  // You can however get the original object through `#valueOf`

  // Types are as follow:

    //typeof true;                          //"boolean"
    //typeof Boolean(true);                 //"boolean"
    //typeof new Boolean(true);             //"object"
    //typeof (new Boolean(true)).valueOf(); //"boolean"

  // This implies that:

    assert_eq(0, Number(0))
    assert_eq(0, new Number(0).valueOf())
    assert_neq(typeof(0), new Number(0))

  // Unlike objects, primitives have no properties.

  // Javascript does implicit coercion between primitives and corresponding types
  // whenever you try access a property of a primitive:

    assert_eq('abc'.length, 3)

  // This creates a String object for a moment, returns the `length`, and then garbage collection kills it.

  // This means that it is not possible to modify a primitive, and the modification happens on the coerced object instead:

    a = 0
    a.b = 1
    assert_eq(a.b, undefined)

  // Operators behave as expected on primitives. In particular,
  // `===` compares their values, not addresses, so for primitives it works as naively expected:

    assert(true  === true)
    assert(0     === 0)
    assert('abc' === 'abc')

  // while it fails for objects, where address is considered:

    assert([] !== [])
    assert({} !== {})

// #undefined

  // There is an undefined constant.

    var a = undefined
    assert_eq(a, undefined)

  // ERROR: Using undeclared variables leads to an error:

    //global_undefined

  // Undefined appears automatically from failed property lookup:

    assert_eq({}.no_yet_defined, undefined)

  // Before ES5, it was possible to redefine `undefined`, so the safest way to check for undefined is via typeof:

    ;(function() {
      var global_undefined
      // Safe all versions:
      assert_eq(typeof global_undefined, 'undefined')
      // Safe starting from JS5:
      assert_eq(global_undefined, undefined)
    })()

// #null

  // Null vs undefined: http://stackoverflow.com/questions/801032/why-is-null-an-object-and-whats-the-difference-between-null-and-undefined

// #floating point

  // Also numbers:

    assert_eq(typeof(0), typeof(0.5))

// #string

    var s = "abc"
    var s = 'abc'
    var s = "\n"
    var s = '\n'
    assert_eq("\n", '\n')
    var s = "'"
    var s = '"'

  // #compare

    // Strings are immutable, therefore comparison works as expected:

      assert_eq('a', 'a')

  // #multiline string literals

    // http://stackoverflow.com/questions/805107/creating-multiline-strings-in-javascript

    // More efficient, less sane when changing indentation levels:

      assert_eq("a\
 b", "a b")

    // Less efficient unless optimized, saner when changing indentation levels, Google style:

      assert_eq("a" +
          "b", "ab")

    // With Js 6 there will be a backtick quoted multiline literal called `NoSubstitutionTemplate`.

    //var htmlString = `Say hello to
//multi-line
//strings!`

  // #escape

    // URL encode:

      assert_eq(escape(" "), "%20")
      assert_eq(unescape(escape(" ")), " ")

  // #replace

    // Perl-like regex replace

      assert_eq("a0ba1b".replace(/a(.)b/g, "$1"), "01")

  // #concat #+

    // Creates new string that is the concatenation of two others.

      var s = "a"
      assert_eq(s + "b", "ab")
      assert_eq(s, "a")

      var s = "a"
      assert_eq(s.concat("b"), "ab")
      assert_eq(s, "a")

      assert_eq("a".concat("b").concat("c"), "abc")

  // #lower #upper

      assert_eq('ab'.toUpperCase(), 'AB')
      assert_eq('AB'.toLowerCase(), 'ab')

  // #new String vs #String

    // Explicit constructor is also available.

    // Unlike for Array which is an object, `String()` and `new String()` do different things:
    // `new Strings` generates an object wrapper, while `String()` generates the primitive.

    // There is almost never reason to use `new String()`

      assert('' === String())
      assert('' !== new String())
      assert(''  == new String())

      assert_eq(typeof(String()),     'string')
      assert_eq(typeof(new String()), 'object')

  // #convert variable to string

    // <stackoverflow.com/questions/5765398/whats-the-best-way-to-convert-a-number-to-a-string >

    // Alternatives:

    // - `x.toString()`: undefined for `null`. Simple to override. My preferred option.
    // - `String()`:     works for `null`, but returns `null` in that case, not `''`.
    // - `'' + n`:       possibly slower, less clear.

      assert_eq(String(null),       'null')
      assert_eq(String(undefined),  'undefined')
      assert_eq(String(0),          '0')
      assert_eq(String([0, 1]),     '0,1')
      assert_eq(String({a:0, b:1}), '[object Object]')

  // #escape HTML

    // < to &lt;, etc.

    // Bo built-in solution: http://stackoverflow.com/questions/24816/escaping-html-strings-with-jquery

// #dict #map #class

  // Everything except the few primitives types are objects.

  // There is no dict in JavaScript, but objects behave just like dicts.
  // This is an interesting design choice, since Objects in languages such as Python or Ruby
  // behave much like maps, so why not remove them entirely?

  // Classes don't exist in Javascript: they are more of a design pattern with a little
  // syntax support than an integral part of the language.

  // #sources

    // - http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/
    // - http://stackoverflow.com/questions/572897/how-does-javascript-prototype-work

  // #attributes #[] #.

    // Attributes can be accessed either via `.` or `[]`.

    // `[]` is more flexible, as it can take any string,
    // while `.` can only take attributes that follow certain rules
    // (TODO which), including not starting with digits.

      var o = {a:0, 'b':1, 2:2}

      assert_eq(o.a,    0)
      assert_eq(o['a'], 0)

      assert_eq(o.b,    1)
      assert_eq(o['b'], 1)

    // ERROR: attribute cannot start with digit for dot `.` notation.

      //assert_eq(o.2, 2)

      assert_eq(o[2],   2)
      assert_eq(o['2'], 2)

    // #attribute lookup order

      // 1) Look in properties of object defined with `defineProperty`.
      // 2) If not found, look at [[Prototype]] attributes.
      // 3) If not found, look at [[Prototype]].[[Prototype]] attributes, and so on, until `null` if found.
      //     In that case, return `undefined`.

  // #Object #Object.create

    // Low level object operations.

    // It is a function like any other "class":

      assert_eq(typeof(Object), 'function')

    // Simplest object:

      var o = Object.create(null)

    // The argument is the prototype:

      assert_eq(Object.getPrototypeOf(o), null)

    // Define some properties:

      Object.defineProperty(o, 'x', {
        value: 1,
        writable: true,
        enumerable: true,
        configurable: true
      })

    // #enumerable

      // Only enumerable properties show up in `for in`.

      // useful to ignore "internals" like `constructor` and other properties:
      // http://stackoverflow.com/questions/17893718/what-does-enumerable-mean

    // Exact same as above: defaults writeable, enumerable and configurable to true.

      o.y = 2

    // Can also set it to a function.

      o.sum = function() {
        return this.x + this.y
      }

      var o2 = Object.create(o)
      assert_eq(Object.getPrototypeOf(o2), o)

      o2.x = 11

      assert_eq(o.x, 1)
      assert_eq(o.y, 2)
      assert_eq(o.sum(), 3)
      assert_eq(o2.x, 11)
      assert_eq(o2.y, 2)

      assert_eq(o.z, undefined)

  // #prototype #[[Prototype]]

    // Exists to allow inheritance-like constructs.
    //
    // There are two *distinct* things called prototype:
    //
    // - a public `prototype` attribute, as in `[].prototype`.
    //
    // - an inaccessible one, called an "Object Internal Property and Methods" on section 8.6.2 of ES5,
    //     and denoted [[Prototype]] in the standard. Firefox makes this property visible through `__proto__`,
    //     but this is not mentioned in the standard.
    //
    //     This is the one used for the property lookup.
    //
    // The relationship between them is:
    // when an object is constructed, the object's `[[Prototype]]` is set to `obj.prototype`.

    // When you do:

      var F = function() {}
      var f = new F()

    // You get:

      /*
      (Function)       (  F  )                                      (f)
      |                | | ^                                        |
      |                | | |                                        |
      |                | | +-------------------------+              |
      |                | |                           |              |
      |                | +--------------+            |              |
      |                |                |            |              |
      |                |                |            |              |
      |[[Prototype]]   |[[Prototype]]   |prototype   |constructor   |[[Prototype]]
      |                |                |            |              |
      |                |                |            |              |
      |                |                | +----------+              |
      |                |                | |                         |
      | ---------------+                | | +-----------------------+
      | |                               | | |
      v v                               v | v
      (Function.prototype)              (F.prototype)
      |                                 |
      |                                 |
      |[[Prototype]]                    |[[Prototype]]
      |                                 |
      |                                 |
      | +-------------------------------+
      | |
      v v
      (Object.prototype)
      | | ^
      | | |
      | | +---------------------------+
      | |                             |
      | +--------------+              |
      |                |              |
      |                |              |
      |[[Prototype]]   |constructor   |prototype
      |                |              |
      |                |              |
      |                | -------------+
      |                | |
      v                v |
      (null)           (Object)
      */

    // The chain ends at:

      assert_eq(Object.getPrototypeOf(Object.prototype), null)
      assert_eq(Object.getPrototypeOf(F), Function.prototype)
      assert_eq(Object.getPrototypeOf(F.prototype), Object.prototype)
      assert_eq(Object.getPrototypeOf(f),  F.prototype)
      assert_eq(Object.getPrototypeOf({}), Object.prototype)

    // #constructor

      // Normally constructor is not automatically found on new objects,
      // but found by lookup on `[[Prototype]]`:

        assert(!f.hasOwnProperty('constructor'))
        assert(!F.hasOwnProperty('constructor'))
        assert_eq(f.constructor, F)
        assert_eq({}.constructor, Object)
        assert_eq(''.constructor, String)
        assert(F.prototype.hasOwnProperty('constructor'))

      // The constructor of every function is a function.

        assert_eq(Object.constructor, Function)
        assert_eq(typeof(Object), 'function')
        assert_eq(Function.constructor, Function)
        assert_eq(typeof(Function), 'function')
        assert_eq(Array.constructor, Function)
        assert_eq(typeof(Array), 'function')
        assert_eq(F.constructor, Function)
        assert_eq(typeof(F), 'function')

      // Unless you hack things up, `prototype.constructor` returns to the object itself.

        assert_eq(Object.prototype.constructor,   Object)
        assert_eq(Array.prototype.constructor,    Array)
        assert_eq(Function.prototype.constructor, Function)
        assert_eq(F.prototype.constructor,        F)

    // prototype is not automatically set set on new objects:

      assert_eq(f.prototype,  undefined)
      assert_eq({}.prototype, undefined)

    // If you modify the prototype without making it a new object, you can add new
    // properties to all objects that have it as [[Property]]:

      F.prototype.a = 1
      assert_eq(f.a, 1)

    // BAD This is also possible if you set prototype itself to be another object.
    // But don't do that, as automatically set properties like `constructor` will
    // get weird values.

      var F = function() {}
      F.prototype = {a:1}
      var f = new F()
      assert_eq(f.a, 1)
      // Not F! Because constructor used to come from `F.prototype`,
      // and now it comes from Object.prototype because {}.__proto__ == Object.prototype.
      assert_eq(f.constructor, Object)

    // #getPrototypeOf #__proto__

      // `Object.getPrototypeOf` returns the `[[Prototype]]`.

      // `__proto__` is a de facto standard which does the same, but is not in ES5.

      // Same as `obj.constructor.prototype`: http://stackoverflow.com/questions/8024879/is-object-getprototypeof-same-as-object-constructor-prototype-in-javascript

        assert_eq(Object.getPrototypeOf([]), [].constructor.prototype)
        assert_eq([].constructor, Array)

      // Primitives don't have prototypes. `TypeError`:

        //Object.getPrototypeOf(0)

  // #Object Literals

      var o = {x:0, y:1}

    // Is the same as:

      //var o = Object.create(Object.prototype);
      //o.x = 0
      //o.y = 1

    // This means that the object literal "inherits" from the same class as Object,
    // and gets many of its useful methods.

    // Proof:

      assert_eq(o.x, 0)
      assert_eq(o.y, 1)
      assert_eq(Object.getPrototypeOf(o), Object.prototype)

  // #Object.prototype

    // Since literals have this prototype, its methods are shared amongst most objects.

      assert_eq(typeof(Object.prototype), 'object')
      assert_eq(Object.prototype.constructor, Object)

    // Methods of Object.prototype include:

    // #hasOwnProperty

      // Check if an object has a property.

      // Does not look up on prototypes.

        o = {a:0}
        o2 = Object.create(obj)
        o2.b = 1
        assert(!o2.hasOwnProperty('a'))
        assert( o2.hasOwnProperty('b'))

  // #new

      var C = function(x, y) {
        this.x = x
        this.y = y
      }

      C.prototype.sum = function() { return this.x + this.y }

    // This is what `new` does:

      function newObject(func) {
        var args = Array.prototype.slice.call(arguments, 1)
        var object = Object.create(func.prototype)
        func.apply(object, args)
        return object
      }

      var o = newObject(C, 1, 2)
      assert_eq(o.x,     1)
      assert_eq(o.sum(), 3)
      assert_eq(Object.getPrototypeOf(o), C.prototype)
      // TODO where is the constructor set?
      assert_eq(o.constructor, C)
      assert_eq(typeof(o), 'object')
      assert_eq(typeof(C), 'function')

    // Objects are separate:

      var o2 = new C(2, 2)
      assert_eq(o2.x, 2)
      assert_eq(o.x,  1)

    // Same with new:

      var C = function(x, y) {
        this.x = x
        this.y = y
      }

      C.prototype.sum = function() { return this.x + this.y }

      var o = new C(1, 2)
      assert_eq(o.x,     1)
      assert_eq(o.sum(), 3)
      assert_eq(Object.getPrototypeOf(o), C.prototype)
      assert_eq(o.constructor, C)
      assert_eq(typeof(o), 'object')
      assert_eq(typeof(C), 'function')

    // Objects are separate:

      var o2 = new C(2, 2)
      assert_eq(o2.x, 2)
      assert_eq(o.x,  1)

  // #object oriented patterns

    // Now that you understand the internals, here are the patterns.

    // #instance methods and variables

      // The standard way to write C++ class-like constructs is via functions + new.
      // http://stackoverflow.com/questions/13190097/whats-the-best-way-to-create-javascript-classes?lq=1

        var C = function(i) {
          // Instance variable.
          this.i = i

          // Method. BAD: uses more memory as each instance gets one.
          this.geti = function() {
            return this.i
          }
        }

        // Method. GOOD.
        C.prototype.inci = function() {
          this.i += 1
        }

        c = new C(0)
        d = new C(10)

        assert_eq(c.i, 0)
        assert_eq(c.geti(), 0)
        c.inci()
        assert_eq(c.geti(), 1)

        assert_eq(d.i, 10)
        assert_eq(d.geti(), 10)
        d.inci()
        assert_eq(d.geti(), 11)

    // #extend #inheritance

      // TODO

        d0 = {a:0,  b:1}
        d1 = {a:10, c:2}
        d2 = {a:20, d:3}
        //assert_eq(d0.extend(d1, d2), {a:20, b:1, c:2, d:3})

  // #iterate dict #loop dict #for in

    // Only enumerable:

      obj = {a:0, b:1}
      keys = []
      for (key in obj) {
        keys.push(key)
      }
      keys.sort()
      assert_eq(keys[0], 'a')
      assert_eq(keys[1], 'b')
      assert_eq(keys.length, 2)

    // #Object.keys

    // Get Array of enumerable property keys:

      obj = {a:0, b:1}
      keys = Object.keys(obj)
      keys.sort()
      assert_eq(keys[0], 'a')
      assert_eq(keys[1], 'b')
      assert_eq(keys.length, 2)

// #Set

  // ES6

    if (Set) {
      var s = new Set()
      s.add('a')
      s.add('a')
      s.add('b')
      assert_eq(s.size, 2)
      assert(s.has('a'))
    } else {
      document.write('<p>#Set not present</p>')
    }

// #function

  // Return is optional:

    function maybe_return(b) {
      if (b) {
        return 0
      }
    }

    assert_eq(maybe_return(true),  0)
    assert_eq(maybe_return(false), undefined)

  // #redefine function. ##`function f() vs var f = function()`

    // http://stackoverflow.com/questions/336859/var-functionname-function-vs-function-functionname

    // Without var, hoisting looks for the last definition.
    // Conclusion: never use multiple functions with the same name.
    // Conclusion 2: always use `f = function` so you don't have to worry about conclusion 1.

      function redefine_func() { return 0; }
      function redefine_func() { return 1; }
      assert_eq(redefine_func(),  2)
      function redefine_func() { return 2; }

      var f = function() { return 0; }
      var f = function() { return 1; }
      assert_eq(f(),  1)
      var f = function f() { return 2; }

    // Name is only set for the `function f`, since `f =` creates an anonymous function:

      function f() {}
      assert_eq(f.name,  'f')

      var f = function() {}
      assert_eq(f.name,  '')

  // #default positional arguments

    // Default positional arguments don't exist, but can be emulated using undefined check:

      var f = function(a) {
        if (typeof a === 'undefined') { a = 0; }
        return a + 1
      }
      assert_eq(f(),  1)
      assert_eq(f(1), 2)

    // CoffeScript allows us to write `f: (a = 0) ->`.

  //TODO named arguments?

  // #call

    // Call a function.

    // Allows to change the value of this via the first parameter.

      var f = function(x, y) { return this.x + x + y + 1; }
      assert_eq(f.call({x: 100}, 0, 10), 111)

    // Use cases for explicit call: http://stackoverflow.com/questions/9001830/the-reason-to-use-js-call-method

  // #apply

    // vs call: http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply

    // Main difference: pass array:

      var f = function(x, y) { return this.x + x + y + 1; }
      assert_eq(f.apply({x: 100}, [0, 10]), 111)

  // It is possible to assign functions to variables:

    var f = function() {
      return 1
    }
    var vf = f
    assert_eq(vf(), 1)

  // Call before definition #hoisting

    // Unlike variables, functions can be defined after usage.

    // At call functions are searched for forwards.

    // This is called hoisting.

    // Hoisting only works within a single script tag, not across them.

      assert_eq(to_be_defined(), 1)
      function to_be_defined() {
        return 1
      }

    // The lookahead only works for `function` statements.

    // It does not work for function expressions in anonymous functions for example:

      //assert_eq(to_be_defined_anon(), 1) //ERROR
      var to_be_defined_anon = function() {
        return 1
      }

  // #pass by reference #pass by value

    // http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language

    // Like Python:

  // #var

    // Create a new variable in current scope instead of using those variables as part of a closure if they exist outside.

    // It is a good practice to always use var, unless you explicitly expect the variable
    // to refer to something on the outer scope.

      var incr_var = function() {
        var i, j
        i += 1
        j += 1
      }

      var incr_novar = function() {
        i += 1
        j += 1
      }

      i = 0
      j = 10
      incr_var()
      assert_eq(i, 0)
      assert_eq(j, 10)

      i = 0
      j = 10
      incr_novar()
      assert_eq(i, 1)
      assert_eq(j, 11)

    // The var statement sets variables to `undefined` instead of generating syntax errors.

      ;(function() {
        var a
        assert_eq(a, undefined)
      })()

    // Its saner to use `var` as the very first thing inside functions,
    // but it does not matter: `var` statements are hoisted.

      var a = 0
      ;(function() {
        assert_eq(a, undefined)
        if (false) {
          var a
        }
      })()

  // #number of #arguments

    // Any number of arguments can be passed to a function.

    // If less arguments are passed on the call than on the definition, missing args are `undefined`.

    // The `arguments` variable can be used to access any of the passed arguments.

      var f = function(a, b) {
        assert_eq(arguments[0], a)
        assert_eq(arguments[1], b)
        return {a:a, b:b, c:arguments[2]}
      }
      assert_eq(f(0).a,       0)
      assert_eq(f(0).b,       undefined)
      assert_eq(f(0).c,       undefined)
      assert_eq(f(0, 1).a,    0)
      assert_eq(f(0, 1).b,    1)
      assert_eq(f(0, 1).c,    undefined)
      assert_eq(f(0, 1, 2).a, 0)
      assert_eq(f(0, 1, 2).b, 1)
      assert_eq(f(0, 1, 2).c, 2)

    // `arguments` is an Array like object. It is not however an actual Array. It only contains the following properties:

    // - callee.
    // - caller. Obsolete.
    // - length.

      var f = function() {
        assert_eq(arguments.length, 2)
        // TODO
        //assert_eq(arguments.callee, this)
      }
      f(0, 1)

    // To convert `arguments` to an Array use the following idiom:

      var f = function() {
        return Array.prototype.slice.call(arguments, 0).sort()
      }
      assert_eq(f(1, 0)[0], 0)

  // #this

    // Great article: <http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/>

    // This is fixed by the function that calls it at call time. Nothing is determined at definition time.

    // ES5 says there is a primitive `[[Call]]` that both `func.call` and `[obj.]func()` call.

    // This primitive looks very much like `call`, so for most purposes you can think they are the same.

    // Before reading this learn about `call`.

    // The following possibilities exist:

      // function call:       this value
      //`f()`:                `window`
      //`'use strict'; f()`:  `undefined`
      //`'obj.obj2.f()`:      `obj.obj2`

    // #this in global functions

        var f = function() { return this }
        assert_eq(f(), window)

      // `f()` gets converted into something like:

        assert_eq(f.call(window), window)

      // With strict, Katz says:
      //
      // > The ECMAScript 5 spec says that undefined is (almost) always passed,
      // > but that the function being called should change its thisValue
      // > to the global object when not in strict mode.
      // > This allows strict mode callers to avoid breaking existing non-strict-mode libraries.
      //
      // I don't know what that means.

        ;(function() {
          'use strict'
          ;(function() {
            // TODO why no undefined?
            //assert_eq(f(), undefined)
            assert_eq(f(), window)
          })()
          assert_eq(f(), window)
        })()

    // #this in methods

      // The method has no information about what called it:
      // all information is passed at call time.

        var obj = {}
        obj.f = function() {
          return this
        }

        assert_eq(obj.f(), obj)

      // Gets converted to:

        assert_eq(f.call(obj), obj)

      // And:

        g = obj.f
        assert_eq(g(), window)

      // Gets converted to:

        assert_eq(g.call(window), window)

      // The same happens in constructs like:

        var F = function() { this.x = 0 }
        var f = new F()

      // but you have to open up the definition of `new`, and you will see that
      // `F` is being called with `this` equal to `f` (what it returns).

      // #bind

        // We often want to "bind" the method to "its" object.

        // This has led to:

        // - a common design pattern with closures:

            var bind = function(func, thisValue) {
              return function() {
                return func.apply(thisValue, arguments);
              }
            }
            obj = {}
            obj.f = function() { return this }
            var boundF = bind(obj.f, obj);
            assert_eq(boundF(), obj)

        // - an ES5 language feature, `bind` method for functions:

            obj = {}
            obj.f = function() { return this }
            var boundF = obj.f.bind(obj);
            assert_eq(boundF(), obj)

    //#this and jQuery

      // jQuery automatically sets `this` to useful things: its not default ES5 behavior.

      // In particular, callbacks have `this` set to the object that generated the event.

    // #this on global scope

      // TODO what happens? In Firefox and Chrome `this` is the `window` object:

        assert_eq(this, window)

        var f = function() {
          assert_eq(this, window)
        }
        f()


  // #closure

    // Function + variables taken from its context.

    // http://stackoverflow.com/questions/111102/how-do-javascript-closures-work

    // Whenever a `var x` or function argument is visible to a function definition,
    // the definition takes those variables in its closure.

    // add1 and add2 are closures. The value of x is part of the closure.

      var makeAdder = function(x) {
        return function(y) {
          return x + y
        }
      }
      var add1 = makeAdder(1)
      var add2 = makeAdder(2)
      assert_eq(add1(3), 4)
      assert_eq(add2(3), 5)

    // The closure can modify its variable.

      var makeIncrementer = function() {
        var x = 0
        return function() {
          x++
          return x
        }
      }
      var incrementer1 = makeIncrementer()
      var incrementer2 = makeIncrementer()
      assert_eq(incrementer1(), 1)
      assert_eq(incrementer1(), 2)
      // Each closure has a different version of the variable.
      assert_eq(incrementer2(), 1)
      assert_eq(incrementer2(), 2)

    // Every function is a closure, but for functions defined outside functions it is not possible to notice it.

    // The variable in the closure and the corresponding one outside are exactly the same.

    ;(function(){
      var x = 0
      var f = function() {
        return x
      }
      x = 1
      assert_eq(f(), 1)
    }())

  // #anonymous function

    var f = function() {return 1}
    assert_eq(f(), 1)

    // #IIFE #immediately invoking function expression #self executing anonymous function

      // Amazing tutorial: http://benalman.com/news/2010/11/immediately-invoked-function-expression/

      // Defined the function and call itself immediately:

        assert_eq((function(x) {return x + 1}(1)), 2)
        assert_eq((function(x) {return x + 1})(1), 2)

      // Both the above are the same:
      // http://stackoverflow.com/questions/3384504/location-of-parenthesis-for-auto-executing-anonymous-javascript-functions

      // Syntax error without parenthesis:

        //function(x) {return x + 1}(1)

      // because:

      // - `function` keyword in the global scope or inside a function -> function declaration (statement)
      //     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function
      //     SyntaxError because function declarations require a name
      // - inside parenthesise, function expression, because there can be no statements inside parenthesis.
      //     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function

      // Name and empty parenthesis also implies a different `SyntaxError`:

        //function foo() {}()

      // Which is he same as:

        //function foo() {};
        //();

      // And `()` is a syntax error, unlike:

        var a = 0
        function foo() { a = 1 }(1)
        assert_eq(a, 0)

      // Which is not a syntax error, but does not execute the function either.

      // There are other less readable ways to coerce the statement to a function expression:

        var a = 0
        a = function() { return 1 }()
        assert_eq(a, 1)

      // Or if you don't care about the return value:

        !function() {}()

      // Major application: create a new scope so as not to affect variables outside.

        var a = {x:1}
        var b = {x:2}
        ;(function(a) {
          var global_undefined = 0
          assert_eq(a.x, 1)
          a.x = -1
          b.x = -2
        })(a)
        assert_eq(a.x, -1)
        assert_eq(b.x, -2)

        assert_raises(
          function() { global_undefined },
          ReferenceError
        )

      // This specially useful if you have a closure callback:

        //;(function() {
        //  var elem = getTheElement()
        //  document.body.addEventListener(
        //    'load',
        //    function() {
        //      // Do something with elem.
        //      //
        //      // Could use getTheElement() again, but would be less efficient
        //      // because of the extra search per callback call.
        //      //
        //      // Without the IIFE, elem could be redefined afterwards,
        //      // which would affect this closure.
        //    },
        //    false
        //  )
        //}())

    // #Module pattern

      // Use IIFE + closures to create objects with private members.

      // Prototype vs closure based techniques:
      // http://stackoverflow.com/questions/3564238/object-oriented-javascript-with-prototypes-vs-closures

        var counter = (function() {
          var i = 0
          return {
            get: function() {
              return i
            },
            set: function(val) {
              i = val
            },
            increment: function() {
              return ++i
            }
          }
        }());
        assert_eq(counter.get(), 0)
        counter.set(3)
        assert_eq(counter.increment(), 4)
        assert_eq(counter.increment(), 5)
        assert_eq(counter.i, undefined)

// #= #assignment operator

  // Variables contain address of data.
  // `=` always takes the address of the data on the right and sets it to the variable on the left.
  // Integers like `0` and `1` *do* have a single (because immutable) address in Javascript.

    var a = 0
    var b = a
    b = 1
    assert_eq(a, 0)

    var a = [0]
    var b = a
    b[0] = 1
    assert_eq(a[0], 1)

    var a = [[0]]
    var b = a
    b[0][0] = 1
    assert_eq(a[0][0], 1)

// #array #[]

    var a = [0, 'a']
    assert_eq(a.length, 2)
    assert_eq(a[0], 0)
    assert_eq(a[1], 'a')

  // Arrays are hash objects: http://stackoverflow.com/questions/6445010/what-is-a-javascript-array
  //
  // Arrays are *not*:
  //
  // - contiguous chunks of data like in C
  //     They could never be contiguous because their objects can have different sizes.
  //
  // - lists like in Python and Ruby, in which doing `a = [0, 1]; a[3] = 2` is an error.
  //
  // Length is updated whenever a key that is an integer is set and larger than current length.
  //
  // This makes length behave like an intuitive array.
  //
  // This allows us to do:

    var a = [1, 0]
    //{0:1, 1:0, length:2}
    a[9] = 2
    //{0:1, 1:0, 9:2}
    assert_eq(a[9], 2)
    assert_eq(a.length, 10)

  // The above does *not* occupy 10 memory slots: only one more.

  // If the new key is not an integer length is not updated:

    a['b'] = 3
    assert_eq(a.b, 3)
    assert_eq(a.length, 10)

  // Like any other non primitive objects:

    assert_neq([], [])

  // There is no short built-in way of comparing them: http://stackoverflow.com/questions/7837456/comparing-two-arrays-in-javascript

  // A good library based workaround is Uderscore.js's isEqual.

  //#Array explicit constructor

    // `new Array` vs `Array`: unlike `new String` vs `String`, they are identical
    // http://stackoverflow.com/questions/8205691/coffeescript-array-vs-new-array

    // `String()` vs `''`: http://stackoverflow.com/questions/931872/whats-the-difference-between-array-and-while-declaring-a-javascript-ar

    // Generates identical objects:

      assert_eq([].constructor,            Array)
      assert_eq(Array().constructor,       Array)
      assert_eq((new Array()).constructor, Array)

    // With a single element, explicit constructor allocates a pre filled array,
    // which is more efficient than adding elements one by one.
    // The contents are unspecified.

      assert_eq(new Array(3).length, 3)
      assert_eq(new Array(3)[0], undefined)

    // As any other function, `Array` can be redefined by an evil script:

      //(function(){
      //  var Array = 1
      //  assert_eq(Array, 1)
      //}())

  // #push #append

    var a = [0, 1]
    a.push(2)
    assert_eq(a[2], 2)

  // #indexOf

    // Get index of element in array. If not present returns -1.

    // ES5. For greater backwards compatibility people still use jQuery `inArray` version.

      assert_eq([2, 0, 1].indexOf(0), 1)
      assert_eq([2, 0, 1].indexOf(3), -1)

  // #slice

      var a = [2, 0, 1].slice(1)
      assert_eq(a[0], 0)
      assert_eq(a[1], 1)
      assert_eq(a.length, 2)

      var a = [2, 0, 1, 3].slice(1, 3)
      assert_eq(a[0], 0)
      assert_eq(a[1], 1)
      assert_eq(a.length, 2)

  // #iterate #forEach

    // for in iterates all properties of an object, so it does *not* work!

    // Use either explicit index or forEach method for arrays.

      var a = [0, 1, 2]
      var total = 0
      for (var i = 0; i < a.length; i++) {
        total += a[i]
      }
      assert_eq(total, 3)

    // forEach is ES5:

      var a = [0, 1, 2]
      var total = 0
      a.forEach(function(x) {
        total += x
      })
      assert_eq(total, 3)


  // #sort

    // In place:

      var a = [1, 2, 0]
      a.sort()

// #exception #try #catch #finaly

  // try catch finally

  // No `else`, use a variable instead:
  // http://stackoverflow.com/questions/4872170/javascript-try-catch-else-finally-like-python-java-ruby-etc

    var a = 0
    try {
      throw 0
    } catch (err) {
      assert_eq(err, 0)
    } finally {
      a = 1
    }
    assert_eq(a, 1)

// #Date

  //new Date() // current date and time
  //new Date(milliseconds) //milliseconds since 1970/01/01
  //new Date(dateString)

    var d = new Date(2000, 1, 2, 3, 4, 5, 6)
    assert_eq(d.getFullYear()    , 2000)
    assert_eq(d.getMonth()       , 1)
    assert_eq(d.getDate()        , 2) // Day of the month.
    assert_eq(d.getHours()       , 3)
    assert_eq(d.getMinutes()     , 4)
    assert_eq(d.getSeconds()     , 5)
    assert_eq(d.getMilliseconds(), 6)

// #dialogs

  // A bit too invasive.

  // User must respond before he can do anything else.

    //alert("an alert")
    //var v = prompt("what:", "default")
</script>

<h2>#JSON</h2>

  <p>ES5, thus also present in Node.js.</p>
  <p>
    For greater portability,
    <a href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js">https://github.com/douglascrockford/JSON-js/blob/master/json2.js</a>
    is a common option through the CDN:
    <a href="http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js">http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js</a>
  </p>
  <script>
    var json = '{"a":1, "b":"c"}'
    var obj = JSON.parse(json)
    assert_eq(obj.a, 1)
    assert_eq(obj.b, 'c')
  </script>

<h2>#eval</h2>

  <p>Run code from string in current environment.</p>
  <script>
    var a = 0
    eval('a = 1')
    eval('var b = 2')
    assert_eq(a, 1)
    assert_eq(b, 2)
  </script>

<h2>#promise</h2>

  <p>ES6, already implemented in some browsers.</p>
  <p>Makes it easier to deal with event success / failure.</p>
  <p>Good article: <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">http://www.html5rocks.com/en/tutorials/es6/promises/</a></p>
  <p>Already implemented by many libraries.</p>
  <p>
    Promises/A+ is an open standard that influences ES6.
    It is followed by the promise implementation of some libraries, but not others,
    notably jQuery.
  </p>
  <p>
    In jQuery, `Promise` is a subset of `Deferreds`.
  </p>
  <p>
    The following implementation exists for Node.js that mimics EC6's exactly:
    <a href="https://github.com/jakearchibald/es6-promise">https://github.com/jakearchibald/es6-promise</a>
  </p>

<h2>#window</h2>

  <p>One of the most important objects.</p>
  <p>Offers an interface to the browser contents.</p>
  <p>May be undefined on Node.js. This can be used to check if we are no Nodejs or browser.</p>
  <p>`window` is the global object in browser implementations: http://www.ecma-international.org/ecma-262/5.1/#sec-15.1</p>
  <p>It is not present in Nodejs.</p>
  <p>All global objects are attributes of window</p>
  <script>
    a = 1
    window.a = 2
    assert_eq(a, 2)
    this.a = 3
    assert_eq(a, 3)
  </script>

  <h3>#height #width #innerHeight #outerHeight</h3>

    <p>Not on IE8.</p>

    <p>Inner does not include scrollbars, toolbars, address bar, tabs:</p>
    <div><code>window.innerHeight</code> = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.innerHeight)</script>
    <div><code>window.innerWidth</code>  = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.innerWidth)</script>

    <p>Outer includes everything:</p>
    <div><code>window.outerHeight</code> = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.outerHeight)</script>
    <div><code>window.outerWidth</code> = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.outerWidth)</script>

  <h3>#scroll #pageXOffset #pageYOffset #scrollBy</h3>

    <p>Get how much scroll was done from top left:</p>
    <div>window.pageXOffset = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.pageXOffset)</script>
    <div>window.pageYOffset = </div>
    <script>previousElement().insertAdjacentHTML('beforeEnd', window.pageYOffset)</script>
    <p>scrollby: TODO window.scrollBy(100,100)</p>

  <h3>#open</h3>

    <p>Opens up new windows / tabs on the browser.</p>
    <p>Popup blockers usually block this.</p>
    <p>Good way to annoy users =)</p>
    <p>Returns a window object.</p>
    <button>Click me to run window.open.</button>
    <script>
      previousElement().addEventListener(
        'click',
        function() {
          var myWindow = window.open('', 'name', 'width=200, height=100');
        },
        false
      )
    </script>
    <p>TODO: what is the `name` parameter?</p>

  <h3>#setInterval #clearInterval</h3>

    <p>Run a function every n milliseconds.</p>
    <p>500ms: <span id="setInterval">0</span> <span class="border" id="clearInterval">Click me to stop.</span></p>
    <script>
      var setIntervalCount = 0
      var interval0 = window.setInterval(function(){
        setIntervalCount++
        document.getElementById('setInterval').innerHTML = setIntervalCount.toString()
      }, 500)
      document.getElementById('clearInterval').addEventListener(
        'click',
        function(even) {
          window.clearInterval(interval0)
          even.target.insertAdjacentHTML('beforeEnd', ' Stopped.')
        },
        true
      )
    </script>

  <h3>#setTimeout</h3>

    <p>Callback once after given number of milliseconds.</p>
    <button>
      Click me. Something will happen in 1 second.
    </button>
    <script>
      previousElement().addEventListener(
        'click',
        function() {
          window.setTimeout(
            function() {
              alert('You clicked me 1 second ago.')
            },
            1000
          )
        },
        false
      )
    </script>

    <p>Asynchronous:</p>
    <script>
      (function() {
        var x = 0
        window.setTimeout(
          function() {
            assert_eq(x, 1)
          },
          1000
        )
        x = 1
      }())
    </script>

  <h3>#non-standard attributes</h3>

    <p>Just for fun.</p>
    <ul>
      <li>history: browser history</li>
      <li>navigator: navigator metadata</li>
    </ul>

<h2>#DOM</h2>

  <h3>#document</h3>

    <p>Interface to the DOM: www.w3.org/DOM/DOMTR</p>
    <p>It is possible to access all DOM attributes of an element: http://www.w3schools.com/jsref/dom_obj_all.asp</p>

    <h4>#write</h4>

      <p>Write after the current script.</p>
      <script>
        document.write('<p>written by document write</p>')
      </script>
      <p>
        Scripts inserted like this will be executed.
        TODO which order?
        http://stackoverflow.com/questions/94141/javascripts-document-write-inline-script-execution-order
        Probably not a good idea to rely on such things.
      </p>
      <script>
        var a = 0
        document.write('<script>a = 1</scr'+'ipt>')
        // TODO deterministic? Firefox and Chromium tests have passed.
        //assert_eq(a, 1)
      </script>
      <script>
        // TODO deterministic? Firefox and Chromium tests have passed.
        //assert_eq(a, 1)
      </script>

  <h3>#NodeList #HTMLCollection</h3>

    <p>
      Many DOM methods do not return an Array but `NodeList` or `HTMLCollecion` objects,
      which are Array-like and support index access, but not all Array operations such as
      `forEach`.
    </p>
    <p>
      To use arbitrary `Array` methods, first convert to an array with
      Array.prototype.slice.call(elem.getElementsByClassName('class'))
    </p>

  <h3>#Selectors</h3>

    <h4>#querySelectorAll</h4>

      <p>Select elements by CSS selector. Very powerful.</p>
      <p>Not supported in IE7.</p>
      <div class="querySelectorAll0">
        <div class="querySelectorAll1">querySelectorAll</div>
      </div>
      <script>
        assert_eq(document.querySelectorAll('.querySelectorAll0 > .querySelectorAll1')[0].innerHTML, 'querySelectorAll')
      </script>

    <h4>#querySelector</h4>

      <p>Same as <code>querySelectorAll()[0]</code></p>

    <h4>#getElementById</h4>

      <script>
        document.write('<div id="getElementById">getElementByid</div>')
        assert_eq(document.getElementById('getElementById').innerHTML, 'getElementByid')
      </script>

    <h4>#getElementsByClassName</h4>

      <p>
        Not implemented on IE8. Alternatives: http://stackoverflow.com/questions/3808808/how-to-get-element-by-class-in-javascript
        IE8 alternatives: use `querySelectorAll` or JQuery.
      </p>
      <script>
        document.write('<div class="getElementsByClassName0 getElementsByClassName1">getElementsByClassName</div>')
        assert_eq(document.getElementsByClassName('getElementsByClassName0')[0].innerHTML, 'getElementsByClassName')
      </script>
      <p>
        The return can be either NodeList or HTMLCollection
        depending on browser versions and standard considered.
        In particular, no `forEach` Array method.
        Good article: https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName
      </p>

    <h4>#getElementsByTagName</h4>

      <p>Some special cases have shortcuts for them:</p>
      <script>
        assert_eq(document.getElementsByTagName('body')[0], document.body)
        assert_eq(document.getElementsByTagName('head')[0], document.head)
      </script>

    <h4>#currentScript</h4>

      <p>Get the current script element:</p>

      <script>
        assert_eq(document.currentScript.parentNode, document.body)
      </script>

  <h3>#nodeType</h3>

    <ul>
      <li>1 : <code>ELEMENT_NODE</code></li>
      <li>2 : <code>ATTRIBUTE_NODE</code></li>
      <li>3 : <code>TEXT_NODE</code></li>
      <li>4 : <code>CDATA_SECTION_NODE</code></li>
      <li>5 : <code>ENTITY_REFERENCE_NODE</code></li>
      <li>6 : <code>ENTITY_NODE</code></li>
      <li>7 : <code>PROCESSING_INSTRUCTION_NODE</code></li>
      <li>8 : <code>COMMENT_NODE</code></li>
      <li>9 : <code>DOCUMENT_NODE</code></li>
      <li>10: <code>DOCUMENT_TYPE_NODE</code></li>
      <li>11: <code>DOCUMENT_FRAGMENT_NODE</code></li>
      <li>12: <code>NOTATION_NODE</code></li>
    </ul>

    <script>
      var parent = strToElement('<div>a<div>b</div>c</div>')
      assert_eq(parent.nodeType, 1)
      assert_eq(parent.childNodes[0].nodeType, 3)
    </script>

  <h3>#tagName</h3>

    <script>
      assert_eq(strToElement('<div></div>').tagName, 'DIV')
    </script>

  <h3>#nodeValue #innerHTML</h3>

    <p>
      *Don't* do `innerHTML += innerHTML + 'something'` unless you are sure it is only a string.
      Otherwise, this would destroy events associated to elements in the `innerHTML`.
      Use `insertAdjacentHTML` instead.
    </p>
    <script>
      var elem = strToElement('<div>a<i>b</i>c</div>')
      assert_eq(elem.firstChild.nodeValue, 'a')
      assert_eq(elem.innerHTML,            'a<i>b</i>c')
    </script>
    <script>
      assert_eq(strToElement('<button>Button innerHTML</button>').innerHTML, 'Button innerHTML')
    </script>

  <h3>#outerHTML</h3>

    <p>Like `innerHTML`, but also includes the tags. Less support than `innerHTML` but increasing.</p>
    <script>
      assert_eq(strToElement('<div>a<i>b</i>c</div>').outerHTML, '<div>a<i>b</i>c</div>')
    </script>

  <h3>#children #firstElementChild #childnodes #firstChild #lastChild</h3>

    <p>Test preparation:</p>
    <script>
      var elem = strToElement('<div id="children">a<i>b</i>c</div>')
    </script>

    <p>Children and firstElementChild: only elements, no text:</p>
    <script>
      assert_eq(elem.children[0].innerHTML,       'b')
      assert_eq(elem.firstElementChild.innerHTML, 'b')
    </script>

    <p>childNodes and firstChild: include text:</p>
    <script>
      assert_eq(elem.firstChild.nodeValue,    'a')
      assert_eq(elem.childNodes[0].nodeValue, 'a')
      assert_eq(elem.lastChild.nodeValue,     'c')
    </script>

    <p>childNodes is of type NodeList. Therefore no forEach.</p>

  <h3>#parentNode #nextSibling #nextElementSibling #previousSibling #previousElementSibling</h3>

    <script>
      var elem = strToElement('<div>a<i>b</i>c<i>d</i>e</div>')
      var firstI = elem.children[0]
      assert_eq(firstI.parentNode.tagName, 'DIV')
      assert_eq(firstI.previousSibling.nodeValue, 'a')
      assert_eq(firstI.previousElementSibling, null)
      assert_eq(firstI.nextSibling.nodeValue, 'c')
      assert_eq(firstI.nextElementSibling.innerHTML, 'd')
    </script>

  <h3>#modify DOM</h3>

    <h4>#insertAdjacentHTML</h4>

      <p>Insert string before or after tag.</p>
      <script>
        document.write('<div>a<span id="insertAdjacentHTML">b</span>c</div>')
        var inner = document.getElementById('insertAdjacentHTML')
        inner.insertAdjacentHTML('beforeBegin', ' <b>beforeBegin</b> ')
        inner.insertAdjacentHTML('afterBegin',  ' afterBegin ')
        inner.insertAdjacentHTML('beforeEnd',   ' beforeEnd ')
        inner.insertAdjacentHTML('afterEnd',    ' <b>afterEnd</b> ')
      </script>

    <h4>#insertBefore #appendChild</h4>

      <p>Insert an element before another.</p>
      <p>Must work with elements: cannot insert string directly. Consider `insertAdjacentHTML` for that.</p>
      <p>TODO what happens when element exists already? Copy?</p>
      <script>
        var parent = strToElement('<div id="insertBefore">a<i>b</i>c</div>')
        var insertBeforeItalic = parent.children[0]
        var newElem = document.createElement('div');
        newElem.appendChild(document.createTextNode('d'));
        parent.insertBefore(newElem, insertBeforeItalic)
        assert_eq(insertBeforeItalic.previousElementSibling.innerHTML, 'd')
      </script>

    <h4>#insertAfter</h4>

      <p>
        Does not exist, but easily defined with `insertBefore`.
        http://stackoverflow.com/questions/4793604/how-to-do-insert-after-in-javascript-without-using-a-library
      </p>

    <h4>#removeChild</h4>

      <p>Must get parent first: http://stackoverflow.com/questions/3387427/javascript-remove-element-by-id</p>
      <script>
        //var element = document.getElementById("element-id");
        //element.parentNode.removeChild(element);
      </script>

  <h3>#getAttribute</h3>

    <script>
      assert_eq(strToElement('<p id="getAttribute"></p>').getAttribute('id'), 'getAttribute')
    </script>

  <h3>#style #CSS</h3>

    <p>Get and set CSS attributes.</p>
    <script>
      document.write('<div id="style" style="background-color:green; color:blue;">#style</div>')
      document.getElementById('style').style.backgroundColor = 'red'
    </script>

  <h3>#HTMLElement #elements</h3>

    <p>
      <code>HTMLElement</code> is the Base element class.
      It is extended by more specific types of element such as <code>HTMLImageElement</code>.
    </p>

    <h4>#createElement</h4>
    <h4>Construction of derived Element types</h4>

      <p>
        The derived element types can be constructed either with <code>document.createElement</code>
        or specific constructors like <code>Image</code>.
      </p>
      <p>
        Both are standard, widely implemented and equivalent. TODO confirm
        <a href="http://stackoverflow.com/questions/6936071/where-are-constructors-such-as-new-image-and-new-option-documented">http://stackoverflow.com/questions/6936071/where-are-constructors-such-as-new-image-and-new-option-documented</a>
        <a href="https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement">https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement</a>
      </p>
      <p>
        <code>new Image</code> vs <code>document.createElement('img')</code>
        <a href="http://stackoverflow.com/questions/6241716/is-there-a-difference-between-new-image-and-document-createelementimg">http://stackoverflow.com/questions/6241716/is-there-a-difference-between-new-image-and-document-createelementimg</a>
      </p>
      <script>
        assert_eq(document.createElement('adsf').constructor, HTMLUnknownElement)
        assert_eq(document.createElement('div') .constructor, HTMLDivElement)
        assert_eq(document.createElement('img') .constructor, HTMLImageElement)
        assert_eq((new Image())                 .constructor, HTMLImageElement)
      </script>

    <h4>Create DOM tree from string.</h4>

      <p>
        Convert string to DOM tree of Elements:
        <a href="http://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro">http://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro</a>
        <code>innerHTML</code> trick:
      </p>
      <script>
        var str = '<div></div>'
        var dummy = document.createElement('div')
        dummy.innerHTML = str
        var elem = dummy.childNodes[0]
        assert_eq(elem.tagName, 'DIV')
      </script>

    <h4>#focus</h4>

      <p>Method of <code>HTMLElement</code> that gives focus to element.</p>
      <p>
        Not all elements can have focus:
        <a href="http://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus">http://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus</a>
      </p>
      <p>
        Get element with focus with <code>activeElement</code>:
        <a href="http://stackoverflow.com/questions/497094/how-do-i-find-out-which-dom-element-has-the-focus">http://stackoverflow.com/questions/497094/how-do-i-find-out-which-dom-element-has-the-focus</a>
        Widely supported. TODO standards?
      </p>

    <h4>#img #Image #HTMLImageElement</h4>

      <h5>src</h5>

        <p>
          <code>src</code> attribute: starts loading as soon as it is set.
          Horrible interface based on side effects of equal operator <code>=</code>.
          TODO: confirm standards and portability.
        </p>
        <button>Click me to set image.</button>
        <img src="i-dont-exist.jpg" alt="flower"/>
        <script>
          ;(function(){
            var img = previousElement()
            var button = img.previousElementSibling
            button.addEventListener(
              'click',
              function() {
                img.src = 'flower.jpg'
              },
              false
            )
          }())
        </script>

      <h5>#complete</h5>

        <p>Set to <code>true</code> when load has finished.</p>
        <p>Set to <code>false</code> when load starts, e.g. <code>img.src = </code>.</p>
        <p>
          Application: do something when image finished loading.
          Must take care not to add the callback after the event happened.
        </p>
        <script>
          //var img1 = document.querySelector('.img-1');
          //function loaded() {
          //  // woo yey image loaded
          //}
          //if (img1.complete) {
          //  loaded();
          //}
          //else {
          //  img1.addEventListener('load', loaded);
          //}
          //img1.addEventListener('error', function() {
          //  // argh everything's broken
          //});
        </script>
        <p>
          The same is not possible for the error event
          since there is no analogous boolean <code>error</code> indicator.
        </p>

    <h4>#textarea</h4>

      <p>Get content with the <code>value</code> property.</p>
      <script>
        document.write(
          '<textarea id="textarea" onkeypress="textarea_func();">default</textarea>' +
          '<div id="textarea-value">Textarea value = <span></span></div>'
        )
        var textarea = document.getElementById('textarea')
        var textarea_value_holder = document.getElementById('textarea-value').lastElementChild
        function textarea_func() {
          textarea_value_holder.innerHTML = textarea.value
        }
        textarea_func()
      </script>

      <h5>#keypress #keydown #keyup #textinput #change</h5>

        <ul>
          <li>change: value of input element changed.</li>
        </ul>

    <h4>#canvas</h4>

      <p>The HTML canvas element was made to be drawn with Javascript and destroy Flash.</p>
      <script>
        document.write(
          '<h2>#canvas</h2>' +
          '<canvas id="canvas" width="200" height="100" style="border:1px solid black;"></canvas>' +
          '<div onclick="canvas_onclick()" class="border">canvas_onclick. Click me!</div>'
        )
        function canvas_onclick() {
          var b_canvas = document.getElementById("canvas");
          var b_context = b_canvas.getContext("2d");
          b_context.fillRect(50, 25, 150, 100);
        }
      </script>

<h2>#events</h2>

  <p>Events are part of the DOM.</p>
  <p>Each event is attached to an element.</p>
  <p>Events propagate</p>
  <p>Like the rest of the DOM, it is a bit messy to find where events are defined.</p>
  <p>A good source is Firefox's documentation https://developer.mozilla.org/en-US/docs/Web/Reference/Events</p>
  <p>The major standards are:</p>
  <ul>
    <li>http://www.w3.org/TR/DOM-Level-3-Events/</li>
    <li>
      Random points of HTML5 like
      http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end
      for `DOMContentLoaded`
    </li>
  </ul>

  <h3>#addEventListener</h3>

    <p>Allows to add an unlimited amount of handlers per event. Better choice than `on` events like `onload`.</p>
    <p>Can be used together with `on` events. TODO check.</p>
    <p>TODO do all events have a on version and an `addEventListener` one?</p>

    <h4>#useCapture parameter #capture vs #bubble</h4>

      <p>Determines the order in which listeners listen to the event.</p>
      <p>TODO exactly how, example</p>
      <p>A listener callback ends, the event is then sent to further listeners by default.</p>

    <h4>#stopPropagation</h4>

      <p>
        Prevent event from being listened on further listeners.
        http://stackoverflow.com/questions/4470417/how-do-i-consume-a-key-event-in-javascript-so-that-it-doesnt-propagate
      </p>
      <p>Only implemented in recent IE. Consider jQuery's `preventDefault` and/or `stopPropagation` if you care.</p>
      <p>TODO example</p>

    <h4>#dispatchEvent #Trigger events programmatically.</h4>

      <p>
        Programmatically trigger events.
        http://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
      </p>
      <p>TODO example</p>
      <p>
        TODO not possible to trigger standard events like click?
        http://stackoverflow.com/questions/809057/how-do-i-programmatically-click-on-an-element-in-firefox
      </p>
      <div id="dispatchEvent"></div>

  <h3>document vs window vs body events</h3>

    <p>
      `document`, `window` and `body` have different possible events.
      TODO understand clearly.
      <a href="http://stackoverflow.com/questions/12045440/difference-between-document-addeventlistener-and-window-addeventlistener">http://stackoverflow.com/questions/12045440/difference-between-document-addeventlistener-and-window-addeventlistener</a>
      <a href="http://stackoverflow.com/questions/191157/window-onload-vs-body-onload">http://stackoverflow.com/questions/191157/window-onload-vs-body-onload</a>
    </p>
    <p>
      You cannot attach events to the `body` element form scripts in the head,
      because the body is not yet part of the DOM!
      Prefer to attach events to the `document` or `window` objects instead.
    </p>

    <div>#FAIL</div>
    <script>
      // IIFE to isolate `fail`.
      ;(function() {
        var fail = previousElement()
        // TODO: why does document and document.body fail?
        window.addEventListener(
          'load',
          function() {
            fail.parentNode.removeChild(fail)
          },
          false
        )
      }())
    </script>

  <h3>Useful events</h3>

    <h4>#DOMContentLoaded</h4>

      <p>HTML5 http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end</p>
      <p>
        `DOMContentLoaded` vs `document.onload`:
        http://stackoverflow.com/questions/2414750/difference-between-domcontentloaded-and-load-events
        Former does not wait for external resources to load, later does.
      </p>
      <p>Used by jQuery's `$(document).ready` method where supported.</p>

      <div>#FAIL</div>
      <script>
        // IIFE to isolate `fail`.
        ;(function() {
          var fail = previousElement()
          document.addEventListener(
            'DOMContentLoaded',
            function() {
              fail.parentNode.removeChild(fail)
            },
            false
          )
        }())
      </script>

      <script>
        window.onload = function(){
          document.getElementById('window-onload').innerHTML = 'window-onload'
        }
      </script>
      <div id="onload"></div>
      <div id="window-onload"></div>
      <script>
        window.onload = function(){
          document.getElementById('window-onload').innerHTML = 'window-onload'
        }
      </script>

    <h4>#load</h4>

      <p>
        Can only be used on `body` or elements that load remote sources such as
        `img`, `link` or remote `script` tags.
        Cannot be used on other elements such as `div`.
      </p>
      <p>
        Both window and document objects have this event:
        http://stackoverflow.com/questions/588040/window-onload-vs-document-onload>
        but `document`'s is probably more useful.
      </p>
      <p>
        On <code>body</code> and <code>document</code>, waits for all content to load,
        including images.
      </p>
      <p>
        If <code>load</code> has already finished when callback is set, it does not get called.
        Fortunately it is possible to check if load completed with <code>complete</code>:
      </p>
      <script>
        //var img1 = document.querySelector('.img-1');
        //function loaded() {
        //  // woo yey image loaded
        //}
        //if (img1.complete) {
        //  loaded();
        //}
        //else {
        //  img1.addEventListener('load', loaded);
        //}
        //img1.addEventListener('error', function() {
        //  // argh everything's broken
        //});
      </script>
      <p>
        The same is not possible for the error event
        since there is no analogous boolean <code>error</code> indicator.
      </p>

    <h4>#error</h4>

      <p>Something like an image failed to load.</p>
      <p>
        Not fired if event already failed before assigning the listener. TODO: sure?
        For 'load', possible to work around via the <code>complete</code> argument,
        but not for error.
        Source: <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">http://www.html5rocks.com/en/tutorials/es6/promises/</a>
      </p>
      <div>#FAIL</div>
      <script>
        // IIFE to isolate `fail`.
        ;(function() {
          var fail = previousElement()
          var img = document.createElement('img')
          img.addEventListener(
            'error',
            function(even) {
              fail.parentNode.removeChild(fail)
            },
            false
          )
          img.src = 'i-dont-exist.jpg'
        }())
      </script>

    <h4>#click</h4>

      <script>
        var elem = strToElement('<p class="border" onclick="onclick_func(event)" style="height:100px;">onclick. Click here.</p>')
        var onclick_func = function(even) {
          even.target.innerHTML += ' click'
        }
        insertBeforeScript(elem)
      </script>

      <script>
        var elem = strToElement('<p class="border" style="height:100px;">addEventListener click. Click here.</p>')
        elem.addEventListener(
          'click',
          function(even) {
            even.target.innerHTML += ' click'
          },
          false
        )
        insertBeforeScript(elem)
      </script>

      <p>Works on buttons:</p>
      <script>
        var elem = strToElement('<button>button addEventListener</button>')
        elem.addEventListener(
          'click',
          function(even) {
            even.target.innerHTML += ' click'
          },
          false
        )
        insertBeforeScript(elem)
      </script>

      <h5>#window.onerror</h5>

        <p>Catches js exceptions? TODO how is that related to load errors of the 'error' event?</p>

<h2>#cookies</h2>

  <p>A way of storing small data strings on user's computer hard disk</p>
  <p>
    View all cookies on Firefox:
    <a href="chrome://browser/content/preferences/cookies.xul">chrome://browser/content/preferences/cookies.xul</a>
  </p>
  <p>Cookies are accessible through DOM</p>
  <p>Cookies can be set/get only for current domain.</p>
  <p>
    WARNING: some browsers may not keep cookies for local files (file://)
    so these tests may fail. Current Firefox does keep the cookies.
  </p>
  <p>Each browser stores its own cookies</p>

  <h3>Cookies in HTTP.</h3>
  <h3>Cookies without Javascript.</h3>

    <p>Cookies can also be set via headers using the `Set-Cookie` header key.</p>
    <p>Cookies are automatically sent to servers by browsers via the `Cookie` header value.</p>
    <p>Cookies are sent from servers to CGI scripts via the `HTTP_COOKIE` env var.</p>
    <p>These are the most reliable methods, there is no need to use js for cookies.</p>

  <h3>#session cookies</h3>

    <p>A cookie based technique to maintain user logged in.</p>
    <ul>
      <li>username/password is sent to server encrypted in some way (HTTP Basic + SSL, POST + SSL)</li>
      <li>
        server authenticates, and creates a large random number, stores it,
        and sends it as a non persistent cookie that is an unique number
      </li>
      <li>
        whenever the user hits another URL, this large number is sent to server.
        and user is logged in.
      </li>
    </ul>
    <p>TODO: how to avoid getting the session hijacked?</p>

<script>
  // #path

    // Cookies can be set only for the **current** path and its parents.

    // E.g.: in `www.abc.com/a/b.html`, the path is `a/a.html`.
    // so `a.html` can set cookies for `/`, `/a/` and `/a/a.html` from `/a/a.html`

    // If the location is a directory, then all subdirs can also get the cookies.
    // E.g.: cookies set for `/` can be seen on `/a/` and on `/b/`

  // #js interface

    // #set values

      // Browser parses the strings.

      // Set keys:

        document.cookie = "key=val;"
        document.cookie = "key=val2;"

      // Only `val2` is kept.

      // BAD:

        document.cookie = "key2=val2;key3=val3"

      // Only `key2` is set. Only a single key can be set at a time.

    // #get values

      // Not possible directly: must parse the `document.cookie` string.

    // #delete values

      // The simplest technique is to set a past expires date.

  // #properties

    // Are special key/value pairs that contain key metadata.

    // #expires

      // Previous key is deleted by browser at given UTC string date:

        var now = new Date()
        var later = now
        later.setMinutes(now.getMinutes() + 1)
        document.cookie += "keyExp=valExp;expires=" + later.toUTCString()

      // If expires is not given, then the cookie expires when the browser is closed!

      // It is not possible to make a cookie that never expires,
      // only one with a huge expiry date.

    // #path

      // Cookie path.

      // Defaults to current file/dir.

      // Can only be set for parent dirs of current path.

    // #safe

      // If set to exactly `= safe`, this cookie will only be sent over `https`, not `http`

        document.cookie = "keySafe=v;safe"

      // TODO confirm usage correct

    // #HttpOnly

      // Instructs server not to pass the cookie to CGI scripts.

      // This can increase security of session cookies.

      // <http://www.codinghorror.com/blog/2008/08/protecting-your-cookies-httponly.html>

        document.cookie = "keySafe=v;HttpOnly"

  // #higher level interface

    // The Javascript cookie interface is very low level and inconvenient.

    // jquery-cookie <https://github.com/carhartl/jquery-cookie> is on popular and convenient cookie interface based on JQuery.

    // #helpers

      // - c_name: string
      // - value: string
      // - exdays: integer. Number of days which will take for the cookie to expire.
      //
      function setCookie(c_name, value, exdays) {
        var exdate = new Date()
        exdate.setDate(exdate.getDate() + exdays)
        var c_value = escape(value) + ((exdays==null) ? "" : "; expires=" + exdate.toUTCString())
        document.cookie = c_name + "=" + c_value
      }

      // c_name: string
      // @return: null if not found, value if found
      //
      function getCookie(c_name) {
        var i, x, y, ARRcookies = document.cookie.split(";")
        for (i = 0; i < ARRcookies.length; i++) {
          x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="))
          y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1)
          x = x.replace(/^\s+|\s+$/g, "")
          if (x == c_name) {
            return unescape(y)
          }
        }
      }

      function delCookie(name, path, domain) {
        if (Get_Cookie(name))
          document.cookie=name+"="+((path) ? ";path="+path:"")+((domain)?";domain="+domain:"") +
                        ";expires=Thu, 01 Jan 1970 00:00:01 GMT"
      }

  document.write('<h2>cookies</h2>' + document.cookie + '<br>')
</script>

<h2>#XMLHttpRquest #AJAX</h2>

  <p>Make server requests without reloading the current page.</p>
  <p>
    2 W3C specs:
  </p>
  <ul>
    <li><a href="http://www.w3.org/TR/XMLHttpRequest/">level 1</a>, widely implemented</li>
    <li><a href="http://www.w3.org/TR/XMLHttpRequest2/">level 2</a>, recent with good implementation status</li>
  </ul>
  <p>Both level 1 and 2 have the same constructor, but level 2 has further capabilities.</p>
  <p>
    Not a part of ES, thus not available in Node.js.
    <a href="https://github.com/driverdan/node-XMLHttpRequest">node-XMLHttpRequest</a>
    is a wrapper for Node.js's stdlib HTTP implementation with interface exactly like this browser object.
  </p>

  <script>
    var xmlhttp = new XMLHttpRequest()
    xmlhttp.open('GET',  'ajax/url', true)
    xmlhttp.open('GET',  'ajax/url?a=1&b=2', true)
    xmlhttp.open('POST', 'ajax/url', true)
    xmlhttp.open('POST', 'ajax/url', true)
    xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest')
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
        document.getElementById("myDiv").innerHTML = xmlhttp.responseText
        // Only if if the response is XML:
        //xmlDoc = xmlhttp.responseXML
        //x = xmlDoc.getElementsByTagName("ARTIST")
        //for (i = 0; i < x.length; i++) {
        //  txt=txt + x[i].childNodes[0].nodeValue + "<br>"
        //}
      }
      //xmlhttp.send()
      //xmlhttp.send("fname=Henry&lname=Ford")
    }
  </script>

  <h3>#open</h3>

    <p>Set basic request info. Does not send the request yet.</p>
    <p>Open signature: `open(method,url,async)</p>
    <p>Post data is set at `send`.</p>

  <h3>#setRequestHeader</h3>

    <p>Allows full control over the HTTP headers.</p>
    <p>Many JS libraries add the following to the header:</p>

  <h3>#response #onreadystatechange</h3>

    <p>Response should be used from a callback function on asynchronous mode.</p>
    <p>`onreadystatechange` callback is called every time the readyState property changes.</p>
    <p>Its possible values are:</p>
    <ul>
      <li>0: request not initialized</li>
      <li>1: server connection established</li>
      <li>2: request received</li>
      <li>3: processing request</li>
      <li>4: request finished and response is ready</li>
    </ul>
    <p>It is typical for the state to go through all of those states.</p>
    <p>TODO how does the server inform which state we are currently on?</p>

      <h4>#responseText</h4>

        <p>Field always present: contains the plain response.</p>

      <h4>#responseXML</h4>

        <p>Field only present if the response type is specified XML on the HTTP headers.</p>

  <h3>#send</h3>

    <p>Actually make the request.</p>

  <h3>#same origin policy #cross origin XMLHttpRequest.</h3>

    <p>
      For security reasons, browsers don't let you do Javascript HTTP requests
      to different locations other than the current one by default,
      otherwise those sites might be able to obtain your session cookies.
      This is called the same origin policy:
      <a href="http://en.wikipedia.org/wiki/Same_origin_policy">http://en.wikipedia.org/wiki/Same_origin_policy</a>
    </p>
    <p>Some browsers have an option to allow that to happen for testing purposes.</p>
    <p>If this happens, you will get <code>xmlhttp.status == 0</code>.</p>

<h2>#FileAPI</h2>

  <p>Local file IO.</p>
  <p>W3C spec.</p>
  <p>Tutorial: <a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/">http://www.html5rocks.com/en/tutorials/file/dndfiles/</a></p>

<h2>#Web Audio API</h2>

  <p>Advanced audio control.</p>
  <p>W3C spec.</p>
  <p>Tutorial: <a href="http://www.html5rocks.com/en/tutorials/webaudio/intro/">http://www.html5rocks.com/en/tutorials/webaudio/intro/</a></p>

<h2>#WebGL</h2>

  <p>OpenGL for the browser.</p>
  <p>W3C spec.</p>
  <p>Wide support on desktop browsers.</p>

</body>
</html>

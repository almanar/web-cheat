<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>js</title>
  <link rel="shortcut icon" type="image/x-icon" href="flower.jpg" />
  <style>
   .border { border:1px solid black; }
  </style>
  <script src="assert.js"></script>
  <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
  <script src="/assets/jquery.toc.js"></script>
  <script>
    $("#toc").toc({
      content: "div.content",
      headings: "h1,h2,h3,h4,h5,h6"
    });
  </script>
</head>
<body onload="document.getElementById('onload').innerHTML = 'onload'">

<h1>Javascript Cheatsheet</h1>

<p>Javascript is a toy language designed to run in a browser.</p>
<p>
  More recently, it has also been used outside of browsers, often server side, through Node.js.
  This cheat shall consider mostly a world without Node.js: for a Node.js cheat see:
  https://github.com/cirosantilli/nodejs
</p>
<p>
  It can be embedded on the HTML given by the server to the browser inside `script` tags.
  It can also be given in separate `.js` files which are then included in the HTML header.
</p>
<p>
  One of the goals of Javascript is to restrict what the language can do to prevent malicious attacks.
  Therefore, by design choice Javascript does not allows dangerous operations such as file IO.
  Node.js adds such abilities to Javascript.
</p>
<p>
  Javascript is known for having some weird quirks. CoffeScript, a language that compiles to Javascript
  but behaves more like Ruby, attempts to correct many of those quirks.
</p>
<ul data-toc></ul>

<h2>#standards #ECMAScript</h2>

  <p>Official language name: ECMA-262, or ECMAScript.</p>
  <ul>
    <li>
      <p>v6</p>
      <p>Expected Dec 2014.</p>
      <p>Good cheat: https://github.com/lukehoban/es6features</p>
    </li>
    <li>
      <p>v 5.1: 2011.</p>
      <p>Generally implemented.</p>
      <p>Often abbreviated to ES5.</p>
      <p>Fully implemented by Google's V8 engine for Chrome and Node.js.</p>
      <p>http://www.ecma-international.org/publications/standards/Ecma-262.htm</p>
    </li>
    <li>v5: 2009</li>
    <li>v4: was aborted</li>
    <li>v3: 1999</li>
  </ul>
  <p>This does not include objects which browsers add to Javascript like `document` or `window`.
    There is currently no readable documentation for those objects, and standards are still sloppy:
    http://stackoverflow.com/questions/3768606/where-is-the-javascript-dom-api-documented
  </p>

<h2>#Style</h2>

  <ul>
    <li>
      GitHub: https://github.com/styleguide/javascript
      <ul>
        <li>2 space indent</li>
        <li>no semicolons</li>
      </ul>
    <li>
      Google: http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
      <ul>
        <li>2 space indent</li>
        <li>semicolons</li>
        <li>single quoted strings by default. Easier to include HTML with attributes, which in their style uses double quotes.</li>
      </ul>
    </li>
    <li>
      Airbnb; https://github.com/airbnb/javascript
      <ul>
        <li>semicolons</li>
      </ul>
    </li>
  </ul>

<h2>#Minification</h2>

  <p>Since Javascript is sent to browsers over the network, methods have been developed to make Javascript code smaller:</p>

  <h3>#Compression</h3>

    <p>Compress Javascript with gzip before sending. Notify browser with `Content-Encoding` HTTP header.</p>

  <h3>#Minification</h3>

    <p>Remove unnecessary characters like whitespaces.</p>

  <h3>#Obfuscation</h3>

    <p>
      Rename variables and functions to shorter names, factor things out in ways
      that are shorter but hard for humans to understand.
    </p>

  <h3>#Concatenation</h3>

    <p>Concatenate multiple Js files together.</p>
    <p>
      OK, not really a form of compression, but serves the same purpose: make things faster,
      in this case by reducing the number of HTTP requests.
    </p>
    <p>
      When writing Javascript code, you must be aware that this can happen, and that it may have consequences.
      See for example the Semicolon before IIFE pattern.
    </p>

<h2>#script element</h2>

  <h3>#script element</h3>

    <p>`script` elements can appear either inside the head or of the body.</p>
    <p>
      The most commonly recommended place is load all scripts just before the `body` tag,
      so that the page can load before long scripts do, so it seems more responsive.
    </p>
    <p>
      It is not valid to put scripts after the /body tag, as HTML specifies that only
      comments can be put there.
    </p>

  <h3>#multiple script elements</h3>

    <p>Scripts are executed in the order which they appear on the file.</p>
    <p>head scripts are executed before body ones.</p>
    <p>Definitions from previous scripts blocks are kept for future script blocks.</p>
    <script>
      var i = 1
    </script>
    <script>
      assert_eq(i, 1)
    </script>
    <p>
      Errors and uncaught exceptions (e.g. undefined variables) only stop execution of the current script block:
      future script blocks still execute. There is no way to prevent future script blocks from executing.
    </p>
    <script>
      global_undefined
    </script>

  <h3>#src attribute</h3>

    <p>Source a script from a separate `.js` file.</p>
    <p>In HTML5, the `script` tag *cannot* be self closing because it is neither `void` nor `foreign`.</p>
    <p>
      In HTML5 you cannot have src and a non empty innerHTML:
      http://stackoverflow.com/questions/6528325/what-does-a-script-tag-with-src-and-content-mean
    </p>
    <script src="external.js"></script>
    <script>
      assert_eq(external, 1)
    </script>

    <h3>#async attribute</h3>

      <p>It is possible to run external scripts asynchronously.</p>
      <p>This makes script run other unpredictable.</p>
      <p>Can only be used for external scripts.</p>
      <script src="external.js" async></script>

  <h3>#type attribute</h3>

    <p>Before HTML5 it was mandatory to specify the language of the script as an attribute to the script tag:</p>
    <code>type="text/javascript"</code>
    <p>In HTML5 js became the default, so the attribute is not needed anymore.</p>

  <h3>Close script tag inside Javascript #/scr'+'ipt</h3>

    <p>
      Any HTML tags can be included inside a script element except the closing script tag.
      The HTML parser just reads everything up to that and then passes it to the Js interpreter.
    </p>
    <p>
      A common technique to write a literal &lt;/script&gt; string inside Javascript it to break it up
      with concatenation as `/scr'+'ipt`
    </p>
    <script>

    </script>

  <h3>#Strict mode #use strict</h3>

    <p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode</p>
    <p>ES5.</p>
    <p>Throws exceptions in a bunch of extra smart cases.</p>
    <p>Turn on for entire script element:</p>
    <script>
      'use strict'
      assert_raises(
        function() {
          01
        },
        SyntaxError
      )
    </script>
    <p>Turn on for single function:</p>
    <script>
      assert_raises(
        function() {
          'use strict'
          01
        },
        SyntaxError
      )

      // TODO why passes?
      assert_raises(
        function() {
          'use strict'
          01
        },
        'asdf'
      )

      assert_not_raises(
        function() {
          01
        }
      )
    </script>

<script>

// #exit

  // Stop interpreting the current script block now.

    //exit()

// #semicolon #;

  // Separates statements.

    var i = 1; i = 2;
    assert_eq(i, 2);

  // #ASI

    // Automatic semicolon insertion.

    // In most cases, semicolons are automatically added by the parser at newlines:

      var i = 1
      i = 2
      assert_eq(i, 2)

    // There are a few complex cases however.

    // http://inimino.org/~inimino/blog/javascript_semicolons

    // Operators inhibit ASI to allow programmers to write:

      var i = 1 +
        1
      assert_eq(i, 2)

      var i = 1
        + 1
      assert_eq(i, 2)

    // Because of ASI, many people use a coding style without semicolons,
    // using them only for the only exception: lines that start with parenthesis:

      var i = 1
      ;(assert_eq(i, 1))

    // One notable case where this happens is for IIFE scope preservation.

    // TODO why are semicolons are not required are in single line functions:

      var f = function() { return 0 }
      assert_eq(f(), 0)
      // Instead of:
      var f = function() { return 0; }

    // Advantages of using semicolons:

      // - slightly saner because you don't have to think if it will be added or not automatically,
      //     but only slightly because the no insertion rule is intuitive, except for the parenthesis case.

      // - slightly better for framework concatenation and minification,
      //     but only slightly because good tools should be able to work around that, and the better compression
      //     method is gzipping it anyways.

    // It is a controversial subject which style is better. This is one of the things CoffeScript takes care of.

    // GitHub style says no semicolons. Rationale: http://mislav.uniqpath.com/2010/05/semicolons/

    // Google says semicolons. Rationale: http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Semicolons

// #comments

  // Like C++.

    // Single line.

    /* Multi
      line.
    */

// #case

  // Javascript is case sensitive

    var i = 1
    var I = 2
    assert_eq(i, 1)
    assert_eq(I, 2)
/*
#identifiers

  Identifiers can contain very weird characters.
  http://stackoverflow.com/questions/1661197/valid-characters-for-javascript-variable-names

  The first character is more restricted than the following ones, for example it cannot be a number.

  Some libraries make extensive use of such variables, notably JQuery which uses the dollar sign `$`
  which is an alias for jQuery.

  Make sure you head > meta > UTF-8 if you really want to use non ASCII identifier chars.
*/

  // This is works, but let's not break jQuery shall we:

    //var $ = 1
    //assert_eq($, 1)

    var ᾏ = 1
    assert_eq(ᾏ, 1)

// #operators

  // #tilde operator #~

    // Binary negation.

    // Common application: transform `-1` into `0` on `indexOf` (jQuery `inArray`).

    // Works because number representation is fixed at 2's complement and in that case:

    // - ~-1 == 0
    // - there is no other number such that ~x == 0.

      assert_eq(~-1,  0)
      assert_eq(~ 0, -1)

  // #comma operator

    i = 1, j = 2
    assert_eq(i, 1)
    assert_eq(j, 2)

  // #boolean

// #if

    if (false) {
      assert(false)
    } else {
    }

    if (true) {
    } else {
      assert(false)
    }

  // Like Python, some objects are converted to true, others to false.

  // Only the following are false:

    if (0) {
      assert(false)
    } else {
    }

    if ("") {
      assert(false)
    } else {
    }

    if (null) {
      assert(false)
    } else {
    }

    if (undefined) {
      assert(false)
    } else {
    }

    if (NaN) {
      assert(false)
    } else {
    }

  // All others are true.

    if (-1) {
    } else {
      assert(false)
    }

    if (1) {
    } else {
      assert(false)
    }

    if ("a") {
    } else {
      assert(false)
    }

    if ([]) {
    } else {
      assert(false)
    }

// #for

  // C like:

    var total = 0
    for (var i = 0; i < 3; i++) {
      total += i
    }
    assert_eq(total, 3)

  // For in: iterates over **object properties**!

    var total = 0
    var obj = {'a': 1, 'b': 2}
    for (var x in obj) {
      total += obj[x]
    }
    assert_eq(total, 3)

// #continue

// #break

  // Both have a label and label-less form.

  // Label-less form is the same as C.

  // break:    without label only inside loops, with valid in any code block.
  // continue: with or without label only inside loops.

    var total = 0;
    for (var i = 0; i < 3; i++) {
      if (i == 1)
        continue
      total += i
    }
    assert_eq(total, 2)

  // TODO understand label form. Good examples: http://www.tutorialspoint.com/javascript/javascript_loop_control.htm

// #primitive types #base types #mutable #immutable

  // http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/

  // There are 5 primitive types in Javascript:

  // - undefined
  // - null
  // - boolean
  // - string
  // - number

  // Everything else is an object.

  // Of the primitive types, `boolean`, `string` and `number` have corresponding Object wrappers: Boolean, String.

  // This is so to allow to simulate the property syntax to those primitive types.

  // You can however get the original object through `#valueOf`

  // Types are as follow:

    //typeof true;                          //"boolean"
    //typeof Boolean(true);                 //"boolean"
    //typeof new Boolean(true);             //"object"
    //typeof (new Boolean(true)).valueOf(); //"boolean"

  // This implies that:

    assert_eq(0, Number(0))
    assert_eq(0, new Number(0).valueOf())
    assert_neq(typeof(0), new Number(0))

  // Unlike objects, primitives have no properties.

  // Javascript does implicit coercion between primitives and corresponding types
  // whenever you try access a property of a primitive:

    assert_eq('abc'.length, 3)

  // This creates a String object for a moment, returns the `length`, and then garbage collection kills it.

  // This means that it is not possible to modify a primitive, and the modification happens on the coerced object instead:

    a = 0
    a.b = 1
    assert_eq(a.b, undefined)

  // Operators behave as expected on primitives. In particular,
  // `===` compares their values, not addresses, so for primitives it works as naively expected:

    assert(true  === true)
    assert(0     === 0)
    assert('abc' === 'abc')

  // while it fails for objects, where address is considered:

    assert([] !== [])
    assert({} !== {})

// #undefined

  // There is an undefined constant.

    var a = undefined
    assert_eq(a, undefined)

  // ERROR: Using undeclared variables leads to an error:

    //global_undefined

  // Undefined appears automatically from failed property lookup:

    assert_eq({}.no_yet_defined, undefined)

  // Before ES5, it was possible to redefine `undefined`, so the safest way to check for undefined is via typeof:

    ;(function() {
      var global_undefined
      // Safe all versions:
      assert_eq(typeof global_undefined, 'undefined')
      // Safe starting from JS5:
      assert_eq(global_undefined, undefined)
    })()

// #null

  // Null vs undefined: http://stackoverflow.com/questions/801032/why-is-null-an-object-and-whats-the-difference-between-null-and-undefined

// #floating point

  // Also numbers:

    assert_eq(typeof(0), typeof(0.5))

// #string

    var s = "abc"
    var s = 'abc'
    var s = "\n"
    var s = '\n'
    assert_eq("\n", '\n')
    var s = "'"
    var s = '"'

  // #compare

    // Strings are immutable, therefore comparison works as expected:

      assert_eq('a', 'a')

  // #multiline strings

    // http://stackoverflow.com/questions/805107/creating-multiline-strings-in-javascript

    // More efficient, less sane when changing indentation levels:

      assert_eq("a\
 b", "a b")

    // Less efficient, saner when changing indentation levels, Google style:

      assert_eq("a" +
          "b", "ab")

    // With Js 6 there will be a backtick quoted multiline literal called `NoSubstitutionTemplate`.

    //var htmlString = `Say hello to
//multi-line
//strings!`

  // #escape

    // URL encode:

      assert_eq(escape(" "), "%20")
      assert_eq(unescape(escape(" ")), " ")

  // #replace

    // Perl-like regex replace

      assert_eq("a0ba1b".replace(/a(.)b/g, "$1"), "01")

  // #concat #+

    // Creates new string that is the concatenation of two others.

      var s = "a"
      assert_eq(s + "b", "ab")
      assert_eq(s, "a")

      var s = "a"
      assert_eq(s.concat("b"), "ab")
      assert_eq(s, "a")

      assert_eq("a".concat("b").concat("c"), "abc")

  // #lower #upper

      assert_eq('ab'.toUpperCase(), 'AB')
      assert_eq('AB'.toLowerCase(), 'ab')

  // #new String vs #String

    // Explicit constructor is also available.

    // Unlike for Array which is an object, `String()` and `new String()` do different things:
    // `new Strings` generates an object wrapper, while `String()` generates the primitive.

    // There is almost never reason to use `new String()`

      assert('' === String())
      assert('' !== new String())
      assert(''  == new String())

      assert_eq(typeof(String()),     'string')
      assert_eq(typeof(new String()), 'object')

  // #convert variable to string

    // <stackoverflow.com/questions/5765398/whats-the-best-way-to-convert-a-number-to-a-string >

    // Alternatives:

    // - `x.toString()`: undefined for `null`. Simple to override. My preferred option.
    // - `String()`:     works for `null`, but returns `null` in that case, not `''`.
    // - `'' + n`:       possibly slower, less clear.

      assert_eq(String(null),       'null')
      assert_eq(String(undefined),  'undefined')
      assert_eq(String(0),          '0')
      assert_eq(String([0, 1]),     '0,1')
      assert_eq(String({a:0, b:1}), '[object Object]')

// #dict #map #class

  // Everything except the few primitives types are objects.

  // There is no dict in JavaScript, but objects behave just like dicts.
  // This is an interesting design choice, since Objects in languages such as Python or Ruby
  // behave much like maps, so why not remove them entirely?

  // Classes don't exist in Javascript: they are more of a design pattern with a little
  // syntax support than an integral part of the language.

  // #sources

    // - http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/
    // - http://stackoverflow.com/questions/572897/how-does-javascript-prototype-work

  // #attributes #[] #.

    // Attributes can be accessed either via `.` or `[]`.

    // `[]` is more flexible, as it can take any string,
    // while `.` can only take attributes that follow certain rules
    // (TODO which), including not starting with digits.

      var o = {a:0, 'b':1, 2:2}

      assert_eq(o.a,    0)
      assert_eq(o['a'], 0)

      assert_eq(o.b,    1)
      assert_eq(o['b'], 1)

    // ERROR: attribute cannot start with digit for dot `.` notation.

      //assert_eq(o.2, 2)

      assert_eq(o[2],   2)
      assert_eq(o['2'], 2)

    // #attribute lookup order

      // 1) Look in properties of object defined with `defineProperty`.
      // 2) If not found, look at [[Prototype]] attributes.
      // 3) If not found, look at [[Prototype]].[[Prototype]] attributes, and so on, until `null` if found.
      //     In that case, return `undefined`.

  // #Object #Object.create

    // Low level object operations.

    // It is a function like any other "class":

      assert_eq(typeof(Object), 'function')

    // Simplest object:

      var o = Object.create(null)

    // The argument is the prototype:

      assert_eq(Object.getPrototypeOf(o), null)

    // Define some properties:

      Object.defineProperty(o, 'x', {
        value: 1,
        writable: true,
        enumerable: true,
        configurable: true
      })

    // Exact same as above: defaults writeable, enumerable and configurable to true.

      o.y = 2

    // Can also set it to a function.

      o.sum = function() {
        return this.x + this.y
      }

      var o2 = Object.create(o)
      assert_eq(Object.getPrototypeOf(o2), o)

      o2.x = 11

      assert_eq(o.x, 1)
      assert_eq(o.y, 2)
      assert_eq(o.sum(), 3)
      assert_eq(o2.x, 11)
      assert_eq(o2.y, 2)

      assert_eq(o.z, undefined)

  // #prototype #[[Prototype]]

    // Exists to allow inheritance-like constructs.
    //
    // There are two *distinct* things called prototype:
    //
    // - a public `prototype` attribute, as in `[].prototype`.
    //
    // - an inaccessible one, called an "Object Internal Property and Methods" on section 8.6.2 of ES5,
    //     and denoted [[Prototype]] in the standard. Firefox makes this property visible through `__proto__`,
    //     but this is not mentioned in the standard.
    //
    //     This is the one used for the property lookup.
    //
    // The relationship between them is:
    // when an object is constructed, the object's `[[Prototype]]` is set to `obj.prototype`.

    // When you do:

      var F = function() {}
      var f = new F()

    // You get:

      /*
      (Function)       (  F  )                                      (f)
      |                | | ^                                        |
      |                | | |                                        |
      |                | | +-------------------------+              |
      |                | |                           |              |
      |                | +--------------+            |              |
      |                |                |            |              |
      |                |                |            |              |
      |[[Prototype]]   |[[Prototype]]   |prototype   |constructor   |[[Prototype]]
      |                |                |            |              |
      |                |                |            |              |
      |                |                | +----------+              |
      |                |                | |                         |
      | ---------------+                | | +-----------------------+
      | |                               | | |
      v v                               v | v
      (Function.prototype)              (F.prototype)
      |                                 |
      |                                 |
      |[[Prototype]]                    |[[Prototype]]
      |                                 |
      |                                 |
      | +-------------------------------+
      | |
      v v
      (Object.prototype)
      | | ^
      | | |
      | | +---------------------------+
      | |                             |
      | +--------------+              |
      |                |              |
      |                |              |
      |[[Prototype]]   |constructor   |prototype
      |                |              |
      |                |              |
      |                | -------------+
      |                | |
      v                v |
      (null)           (Object)
      */

    // The chain ends at:

      assert_eq(Object.getPrototypeOf(Object.prototype), null)
      assert_eq(Object.getPrototypeOf(F), Function.prototype)
      assert_eq(Object.getPrototypeOf(F.prototype), Object.prototype)
      assert_eq(Object.getPrototypeOf(f),  F.prototype)
      assert_eq(Object.getPrototypeOf({}), Object.prototype)

    // #constructor

      // Normally constructor is not automatically found on new objects,
      // but found by lookup on `[[Prototype]]`:

        assert(!f.hasOwnProperty('constructor'))
        assert(!F.hasOwnProperty('constructor'))
        assert_eq(f.constructor, F)
        assert_eq({}.constructor, Object)
        assert_eq(''.constructor, String)
        assert(F.prototype.hasOwnProperty('constructor'))

      // The constructor of every function is a function.

        assert_eq(Object.constructor, Function)
        assert_eq(typeof(Object), 'function')
        assert_eq(Function.constructor, Function)
        assert_eq(typeof(Function), 'function')
        assert_eq(Array.constructor, Function)
        assert_eq(typeof(Array), 'function')
        assert_eq(F.constructor, Function)
        assert_eq(typeof(F), 'function')

      // Unless you hack things up, `prototype.constructor` returns to the object itself.

        assert_eq(Object.prototype.constructor,   Object)
        assert_eq(Array.prototype.constructor,    Array)
        assert_eq(Function.prototype.constructor, Function)
        assert_eq(F.prototype.constructor,        F)

    // prototype is not automatically set set on new objects:

      assert_eq(f.prototype,  undefined)
      assert_eq({}.prototype, undefined)

    // If you modify the prototype without making it a new object, you can add new
    // properties to all objects that have it as [[Property]]:

      F.prototype.a = 1
      assert_eq(f.a, 1)

    // BAD This is also possible if you set prototype itself to be another object.
    // But don't do that, as automatically set properties like `constructor` will
    // get weird values.

      var F = function() {}
      F.prototype = {a:1}
      var f = new F()
      assert_eq(f.a, 1)
      // Not F! Because constructor used to come from `F.prototype`,
      // and now it comes from Object.prototype because {}.__proto__ == Object.prototype.
      assert_eq(f.constructor, Object)

    // #getPrototypeOf #__proto__

      // `Object.getPrototypeOf` returns the `[[Prototype]]`.

      // `__proto__` is a de facto standard which does the same, but is not in ES5.

      // Same as `obj.constructor.prototype`: http://stackoverflow.com/questions/8024879/is-object-getprototypeof-same-as-object-constructor-prototype-in-javascript

        assert_eq(Object.getPrototypeOf([]), [].constructor.prototype)
        assert_eq([].constructor, Array)

      // Primitives don't have prototypes. `TypeError`:

        //Object.getPrototypeOf(0)

  // #Object Literals

      var o = {x:0, y:1}

    // Is the same as:

      //var o = Object.create(Object.prototype);
      //o.x = 0
      //o.y = 1

    // This means that the object literal "inherits" from the same class as Object,
    // and gets many of its useful methods.

    // Proof:

      assert_eq(o.x, 0)
      assert_eq(o.y, 1)
      assert_eq(Object.getPrototypeOf(o), Object.prototype)

  // #Object.prototype

    // Since literals have this prototype, its methods are shared amongst most objects.

      assert_eq(typeof(Object.prototype), 'object')
      assert_eq(Object.prototype.constructor, Object)

    // Methods of Object.prototype include:

    // #hasOwnProperty

      // Check if an object has a property.

      // Does not look up on prototypes.

        o = {a:0}
        o2 = Object.create(obj)
        o2.b = 1
        assert(!o2.hasOwnProperty('a'))
        assert( o2.hasOwnProperty('b'))

  // #new

      var C = function(x, y) {
        this.x = x
        this.y = y
      }

      C.prototype.sum = function() { return this.x + this.y }

    // This is what `new` does:

      function newObject(func) {
        var args = Array.prototype.slice.call(arguments, 1)
        var object = Object.create(func.prototype)
        func.apply(object, args)
        return object
      }

      var o = newObject(C, 1, 2)
      assert_eq(o.x,     1)
      assert_eq(o.sum(), 3)
      assert_eq(Object.getPrototypeOf(o), C.prototype)
      // TODO where is the constructor set?
      assert_eq(o.constructor, C)
      assert_eq(typeof(o), 'object')
      assert_eq(typeof(C), 'function')

    // Objects are separate:

      var o2 = new C(2, 2)
      assert_eq(o2.x, 2)
      assert_eq(o.x,  1)

    // Same with new:

      var C = function(x, y) {
        this.x = x
        this.y = y
      }

      C.prototype.sum = function() { return this.x + this.y }

      var o = new C(1, 2)
      assert_eq(o.x,     1)
      assert_eq(o.sum(), 3)
      assert_eq(Object.getPrototypeOf(o), C.prototype)
      assert_eq(o.constructor, C)
      assert_eq(typeof(o), 'object')
      assert_eq(typeof(C), 'function')

    // Objects are separate:

      var o2 = new C(2, 2)
      assert_eq(o2.x, 2)
      assert_eq(o.x,  1)

  // #this

    // Great article: <http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/>

    // This is fixed by the function that calls it at call time. Nothing is determined at definition time.

    // ES5 says there is a primitive `[[Call]]` that both `func.call` and `[obj.]func()` call.

    // This primitive looks very much like `call`, so for most purposes you can think they are the same.

    // Before reading this learn about `call`.

    // The following possibilities exist:

      // function call:       this value
      //`f()`:                `window`
      //`'use strict'; f()`:  `undefined`
      //`'obj.obj2.f()`:      `obj.obj2`

    // #this in global functions

        var f = function() { return this }
        assert_eq(f(), window)

      // `f()` gets converted into something like:

        assert_eq(f.call(window), window)

      // With strict, Katz says:
      //
      // > The ECMAScript 5 spec says that undefined is (almost) always passed,
      // > but that the function being called should change its thisValue
      // > to the global object when not in strict mode.
      // > This allows strict mode callers to avoid breaking existing non-strict-mode libraries.
      //
      // I don't know what that means.

        ;(function() {
          'use strict'
          ;(function() {
            // TODO why no undefined?
            //assert_eq(f(), undefined)
            assert_eq(f(), window)
          })()
          assert_eq(f(), window)
        })()

    // #this in methods

      // The method has no information about what called it:
      // all information is passed at call time.

        var obj = {}
        obj.f = function() {
          return this
        }

        assert_eq(obj.f(), obj)

      // Gets converted to:

        assert_eq(f.call(obj), obj)

      // And:

        g = obj.f
        assert_eq(g(), window)

      // Gets converted to:

        assert_eq(g.call(window), window)

      // The same happens in constructs like:

        var F = function() { this.x = 0 }
        var f = new F()

      // but you have to open up the definition of `new`, and you will see that
      // `F` is being called with `this` equal to `f` (what it returns).

      // #bind

        // We often want to "bind" the method to "its" object.

        // This has led to:

        // - a common design pattern with closures:

            var bind = function(func, thisValue) {
              return function() {
                return func.apply(thisValue, arguments);
              }
            }
            obj = {}
            obj.f = function() { return this }
            var boundF = bind(obj.f, obj);
            assert_eq(boundF(), obj)

        // - an ES5 language feature, `bind` method for functions:

            obj = {}
            obj.f = function() { return this }
            var boundF = obj.f.bind(obj);
            assert_eq(boundF(), obj)

    //#this and jQuery

      // jQuery automatically sets `this` to useful things: its not default ES5 behavior.

      // In particular, callbacks have `this` set to the object that generated the event.

    // #this on global scope

      // TODO what happens? In Firefox and Chrome `this` is the `window` object:

        assert_eq(this, window)

        var f = function() {
          assert_eq(this, window)
        }
        f()

  // #object oriented patterns

    // Now that you understand the internals, here are the patterns.

    // #instance methods and variables

      // The standard way to write C++ class-like constructs is via functions + new.
      // http://stackoverflow.com/questions/13190097/whats-the-best-way-to-create-javascript-classes?lq=1

        var C = function(i) {
          // Instance variable.
          this.i = i

          // Method. BAD: uses more memory as each instance gets one.
          this.geti = function() {
            return this.i
          }
        }

        // Method. GOOD.
        C.prototype.inci = function() {
          this.i += 1
        }

        c = new C(0)
        d = new C(10)

        assert_eq(c.i, 0)
        assert_eq(c.geti(), 0)
        c.inci()
        assert_eq(c.geti(), 1)

        assert_eq(d.i, 10)
        assert_eq(d.geti(), 10)
        d.inci()
        assert_eq(d.geti(), 11)

    // #extend #inheritance

      // TODO

        d0 = {a:0,  b:1}
        d1 = {a:10, c:2}
        d2 = {a:20, d:3}
        //assert_eq(d0.extend(d1, d2), {a:20, b:1, c:2, d:3})

// #function

  // Return is optional:

    function maybe_return(b) {
      if (b) {
        return 0
      }
    }

    assert_eq(maybe_return(true),  0)
    assert_eq(maybe_return(false), undefined)

  // #redefine function. ##`function f() vs var f = function()`

    // http://stackoverflow.com/questions/336859/var-functionname-function-vs-function-functionname

    // Without var, hoisting looks for the last definition.
    // Conclusion: never use multiple functions with the same name.
    // Conclusion 2: always use `f = function` so you don't have to worry about conclusion 1.

      function redefine_func() { return 0; }
      function redefine_func() { return 1; }
      assert_eq(redefine_func(),  2)
      function redefine_func() { return 2; }

      var f = function() { return 0; }
      var f = function() { return 1; }
      assert_eq(f(),  1)
      var f = function f() { return 2; }

    // Name is only set for the `function f`, since `f =` creates an anonymous function:

      function f() {}
      assert_eq(f.name,  'f')

      var f = function() {}
      assert_eq(f.name,  '')

  // #default positional arguments

    // Default positional arguments don't exist, but can be emulated using undefined check:

      var f = function(a) {
        if (typeof a === 'undefined') { a = 0; }
        return a + 1
      }
      assert_eq(f(),  1)
      assert_eq(f(1), 2)

    // CoffeScript allows us to write `f: (a = 0) ->`.

  //TODO named arguments?

  // #call

    // Call a function.

    // Allows to change the value of this via the first parameter.

      var f = function(x, y) { return this.x + x + y + 1; }
      assert_eq(f.call({x: 100}, 0, 10), 111)

    // Use cases for explicit call: http://stackoverflow.com/questions/9001830/the-reason-to-use-js-call-method

  // #apply

    // vs call: http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply

    // Main difference: pass array:

      var f = function(x, y) { return this.x + x + y + 1; }
      assert_eq(f.apply({x: 100}, [0, 10]), 111)

  // It is possible to assign functions to variables:

    var f = function() {
      return 1
    }
    var vf = f
    assert_eq(vf(), 1)

  // Call before definition #hoisting

    // Unlike variables, functions can be defined after usage.

    // At call functions are searched for forwards.

    // This is called hoisting.

    // Hoisting only works within a single script tag, not across them.

      assert_eq(to_be_defined(), 1)
      function to_be_defined() {
        return 1
      }

    // The lookahead only works for `function` statements.

    // It does not work for function expressions in anonymous functions for example:

      //assert_eq(to_be_defined_anon(), 1) //ERROR
      var to_be_defined_anon = function() {
        return 1
      }

  // #pass by reference #pass by value

    // http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language

    // Like Python:

  // #var

    // Create a new variable in current scope instead of using those variables as part of a closure if they exist outside.

    // It is a good practice to always use var, unless you explicitly expect the variable
    // to refer to something on the outer scope.

      var incr_var = function() {
        var i, j
        i += 1
        j += 1
      }

      var incr_novar = function() {
        i += 1
        j += 1
      }

      i = 0
      j = 10
      incr_var()
      assert_eq(i, 0)
      assert_eq(j, 10)

      i = 0
      j = 10
      incr_novar()
      assert_eq(i, 1)
      assert_eq(j, 11)

    // The var statement sets variables to `undefined` instead of generating syntax errors.

      ;(function() {
        var a
        assert_eq(a, undefined)
      })()

    // Its saner to use `var` as the very first thing inside functions,
    // but it does not matter: `var` statements are hoisted.

      var a = 0
      ;(function() {
        assert_eq(a, undefined)
        if (false) {
          var a
        }
      })()

  // #number of #arguments

    // Any number of arguments can be passed to a function.

    // If less arguments are passed on the call than on the definition, missing args are `undefined`.

    // The `arguments` variable can be used to access any of the passed arguments.

      var f = function(a, b) {
        assert_eq(arguments[0], a)
        assert_eq(arguments[1], b)
        return {a:a, b:b, c:arguments[2]}
      }
      assert_eq(f(0).a,       0)
      assert_eq(f(0).b,       undefined)
      assert_eq(f(0).c,       undefined)
      assert_eq(f(0, 1).a,    0)
      assert_eq(f(0, 1).b,    1)
      assert_eq(f(0, 1).c,    undefined)
      assert_eq(f(0, 1, 2).a, 0)
      assert_eq(f(0, 1, 2).b, 1)
      assert_eq(f(0, 1, 2).c, 2)

    // `arguments` is an Array like object. It is not however an actual Array. It only contains the following properties:

    // - callee.
    // - caller. Obsolete.
    // - length.

      var f = function() {
        assert_eq(arguments.length, 2)
        // TODO
        //assert_eq(arguments.callee, this)
      }
      f(0, 1)

    // To convert `arguments` to an Array use the following idiom:

      var f = function() {
        return Array.prototype.slice.call(arguments, 0).sort()
      }
      assert_eq(f(1, 0)[0], 0)

  // #closure

    // Function + variables taken from its context.

    // http://stackoverflow.com/questions/111102/how-do-javascript-closures-work

    // add1 and add2 are closures. The value of x is part of the closure.

      var makeAdder = function(x) {
        return function(y) {
          return x + y
        }
      }
      var add1 = makeAdder(1)
      var add2 = makeAdder(2)
      assert_eq(add1(3), 4)
      assert_eq(add2(3), 5)

    // The closure can modify its variable.

      var makeIncrementer = function() {
        var x = 0
        return function() {
          x++
          return x
        }
      }
      var incrementer1 = makeIncrementer()
      var incrementer2 = makeIncrementer()
      assert_eq(incrementer1(), 1)
      assert_eq(incrementer1(), 2)
      // Each closure has a different version of the variable.
      assert_eq(incrementer2(), 1)
      assert_eq(incrementer2(), 2)

    // Every function is a closure, but for functions defined outside functions it is not possible to notice it.

  // #anonymous function

    var f = function() {return 1}
    assert_eq(f(), 1)

    // #IIFE #immediately invoking function expression #self executing anonymous function

      // Amazing tutorial: http://benalman.com/news/2010/11/immediately-invoked-function-expression/

      // Defined the function and call itself immediately:

        assert_eq((function(x) {return x + 1}(1)), 2)
        assert_eq((function(x) {return x + 1})(1), 2)

      // Both the above are the same:
      // http://stackoverflow.com/questions/3384504/location-of-parenthesis-for-auto-executing-anonymous-javascript-functions

      // Syntax error without parenthesis:

        //function(x) {return x + 1}(1)

      // because:

      // - `function` keyword in the global scope or inside a function -> function declaration (statement)
      //     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function
      //     SyntaxError because function declarations require a name
      // - inside parenthesise, function expression, because there can be no statements inside parenthesis.
      //     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function

      // Name and empty parenthesis also implies a different `SyntaxError`:

        //function foo() {}()

      // Which is he same as:

        //function foo() {};
        //();

      // And `()` is a syntax error, unlike:

        var a = 0
        function foo() { a = 1 }(1)
        assert_eq(a, 0)

      // Which is not a syntax error, but does not execute the function either.

      // There are other less readable ways to coerce the statement to a function expression:

        var a = 0
        a = function() { return 1 }()
        assert_eq(a, 1)

      // Or if you don't care about the return value:

        !function() {}()

      // Applications:
      //
      // - hide variable definitions from global scope

        var a = {x:1}
        var b = {x:2}
        ;(function(a) {
          var global_undefined = 0
          assert_eq(a.x, 1)
          a.x = -1
          b.x = -2
        })(a)
        assert_eq(a.x, -1)
        assert_eq(b.x, -2)

        assert_raises(
          function() { global_undefined },
          ReferenceError
        )

      // #semicolon before IIFE

        // http://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function

        // IIFE preceded by a semicolon, specially at the start of the file:

          ;(function() {})()
          ;(function() {})()

        // Rationale: prevent break when files are concatenated during minification because of ASI exception rules:

          var a
          (function() {})()
          //(function(){})()

    // #Module pattern

      // Use IIFE + closures to create objects with private members.

      // Prototype vs closure based techniques:
      // http://stackoverflow.com/questions/3564238/object-oriented-javascript-with-prototypes-vs-closures

        var counter = (function() {
          var i = 0
          return {
            get: function() {
              return i
            },
            set: function(val) {
              i = val
            },
            increment: function() {
              return ++i
            }
          }
        }());
        assert_eq(counter.get(), 0)
        counter.set(3)
        assert_eq(counter.increment(), 4)
        assert_eq(counter.increment(), 5)
        assert_eq(counter.i, undefined)

// #= #assignment operator

  // Variables contain address of data.
  // `=` always takes the address of the data on the right and sets it to the variable on the left.
  // Integers like `0` and `1` *do* have a single (because immutable) address in Javascript.

    var a = 0
    var b = a
    b = 1
    assert_eq(a, 0)

    var a = [0]
    var b = a
    b[0] = 1
    assert_eq(a[0], 1)

    var a = [[0]]
    var b = a
    b[0][0] = 1
    assert_eq(a[0][0], 1)

// #array #[]

    var a = [0, 'a']
    assert_eq(a.length, 2)
    assert_eq(a[0], 0)
    assert_eq(a[1], 'a')

  // Arrays are hash objects: http://stackoverflow.com/questions/6445010/what-is-a-javascript-array
  //
  // Arrays are *not*:
  //
  // - contiguous chunks of data like in C
  //     They could never be contiguous because their objects can have different sizes.
  //
  // - lists like in Python and Ruby, in which doing `a = [0, 1]; a[3] = 2` is an error.
  //
  // Length is updated whenever a key that is an integer is set and larger than current length.
  //
  // This makes length behave like an intuitive array.
  //
  // This allows us to do:

    var a = [1, 0]
    //{0:1, 1:0, length:2}
    a[9] = 2
    //{0:1, 1:0, 9:2}
    assert_eq(a[9], 2)
    assert_eq(a.length, 10)

  // The above does *not* occupy 10 memory slots: only one more.

  // If the new key is not an integer length is not updated:

    a['b'] = 3
    assert_eq(a.b, 3)
    assert_eq(a.length, 10)

  // Like any other non primitive objects:

    assert_neq([], [])

  // There is no short built-in way of comparing them: http://stackoverflow.com/questions/7837456/comparing-two-arrays-in-javascript

  // A good library based workaround is Uderscore.js's isEqual.

  //#Array explicit constructor

    // `new Array` vs `Array`: unlike `new String` vs `String`, they are identical
    // http://stackoverflow.com/questions/8205691/coffeescript-array-vs-new-array

    // `String()` vs `''`: http://stackoverflow.com/questions/931872/whats-the-difference-between-array-and-while-declaring-a-javascript-ar

    // Generates identical objects:

      assert_eq([].constructor,            Array)
      assert_eq(Array().constructor,       Array)
      assert_eq((new Array()).constructor, Array)

    // With a single element, explicit constructor allocates a pre filled array,
    // which is more efficient than adding elements one by one.
    // The contents are unspecified.

      assert_eq(new Array(3).length, 3)
      assert_eq(new Array(3)[0], undefined)

    // As any other function, `Array` can be redefined by an evil script:

      //(function(){
      //  var Array = 1
      //  assert_eq(Array, 1)
      //}())

  // #push #append

    var a = [0, 1]
    a.push(2)
    assert_eq(a[2], 2)

  // #indexOf

    // Get index of element in array. If not present returns -1.

    // ES5. For greater backwards compatibility people still use jQuery `inArray` version.

      assert_eq([2, 0, 1].indexOf(0), 1)
      assert_eq([2, 0, 1].indexOf(3), -1)

  // #slice

      var a = [2, 0, 1].slice(1)
      assert_eq(a[0], 0)
      assert_eq(a[1], 1)
      assert_eq(a.length, 2)

      var a = [2, 0, 1, 3].slice(1, 3)
      assert_eq(a[0], 0)
      assert_eq(a[1], 1)
      assert_eq(a.length, 2)

  // #iterate #forEach

    // for in iterates all attributes, so it does *not* work!

    // Use either explicit index or forEach method for arrays.

      var a = [0, 1, 2]
      var total = 0
      for (var i = 0; i < a.length; i++) {
        total += a[i]
      }
      assert_eq(total, 3)

    // forEach is ES5:

      var a = [0, 1, 2]
      var total = 0
      a.forEach(function(x) {
        total += x
      })
      assert_eq(total, 3)

// #exception #try #catch #finaly

  // try catch finally

  // No `else`, use a variable instead:
  // http://stackoverflow.com/questions/4872170/javascript-try-catch-else-finally-like-python-java-ruby-etc

    var a = 0
    try {
      throw 0
    } catch (err) {
      assert_eq(err, 0)
    } finally {
      a = 1
    }
    assert_eq(a, 1)

// #Date

  //new Date() // current date and time
  //new Date(milliseconds) //milliseconds since 1970/01/01
  //new Date(dateString)

    var d = new Date(2000, 1, 2, 3, 4, 5, 6)
    assert_eq(d.getFullYear()    , 2000)
    assert_eq(d.getMonth()       , 1)
    assert_eq(d.getDate()        , 2) // Day of the month.
    assert_eq(d.getHours()       , 3)
    assert_eq(d.getMinutes()     , 4)
    assert_eq(d.getSeconds()     , 5)
    assert_eq(d.getMilliseconds(), 6)

// #dialogs

  // A bit too invasive.

  // User must respond before he can do anything else.

    //alert("an alert")
    //var v = prompt("what:", "default")
</script>

<h2>#window</h2>

  <p>One of the most important objects.</p>
  <p>Offers an interface to the browser contents.</p>
  <p>May be undefined on Node.js. This can be used to check if we are no Nodejs or browser.</p>
  <p>`window` is the global object in browser implementations: http://www.ecma-international.org/ecma-262/5.1/#sec-15.1</p>
  <p>It is not present in Nodejs.</p>
  <p>All global objects are attributes of window</p>
  <script>
    a = 1
    window.a = 2
    assert_eq(a, 2)
    this.a = 3
    assert_eq(a, 3)
  </script>

  <h3>#height #width #innerHeight #outer</h3>

    <p>Not on IE8.</p>
    <p>Inner does not include scrollbars, toolbars, address bar, tabs:</p>
    <div>window.innerHeight = <script>document.write(window.innerHeight)</script></div>
    <div>window.innerWidth  = <script>document.write(window.innerWidth) </script></div>
    <p>Outer includes everything:</p>
    <div>window.outerHeight = <script>document.write(window.outerHeight)</script></div>
    <div>window.outerWidth  = <script>document.write(window.outerWidth) </script></div>

  <h3>#scroll #pageXOffset #pageYOffset #scrollBy</h3>

    <p>Get how much scroll was done from top left:</p>
    <div>window.pageXOffset = <script>document.write(window.pageXOffset)</script></div>
    <div>window.pageYOffset = <script>document.write(window.pageYOffset)</script></div>
    <p>scrollby: TODO window.scrollBy(100,100)</p>
    <script>
    // #open

      // Opens up new windows / tabs on the browser.

      // Popup blockers usually block this.

      // Good way to annoy users =)

      // Returns a window object.

        //var myWindow = window.open("", "name", "width=200, height=100");

    // #name

      // Not necessarily the HTML title:

        //assert_eq(window.name, "js cheat")

      // Can be set when opening a window with open.
    </script>

  <h3>#setInterval #clearInterval</h3>

    <p>Run a function every n milliseconds.</p>
    <p>Seconds since load: <span id="setInterval">0</span> <span class="border" id="clearInterval">Click me to stop.</span></p>
    <script>
      var setIntervalCount = 0
      var interval0 = window.setInterval(function(){
        setIntervalCount++
        document.getElementById('setInterval').innerHTML = setIntervalCount.toString()
      }, 1000)
      document.getElementById('clearInterval').addEventListener(
        'click',
        function(event) {
          alert('here')
          //window.clearInterval(interval0)
        },
        true
      )
    </script>

  <h3>#non-standard attributes</h3>

    <p>Just for fun.</p>
    <ul>
      <li>history: browser history</li>
      <li>navigator: navigator metadata</li>
    </ul>

<h2>#DOM</h2>

<h2>#document</h2>

  <p>Interface to the DOM: www.w3.org/DOM/DOMTR</p>
  <p>It is possible to access all DOM attributes of an element: http://www.w3schools.com/jsref/dom_obj_all.asp</p>
  <p>Shortcut for `window.document`:</p>
  <script>assert_eq(document, window.document)</script>

  <h3>#write</h3>

    <p>Write at the current script location:</p>
    <script>document.write('here')</script>

    <p>
      Scripts inserted like this will be executed.
      TODO which order?
      http://stackoverflow.com/questions/94141/javascripts-document-write-inline-script-execution-order
      Probably not a good idea to rely on such things.
    </p>
    <script>
      var a = 0
      document.write('<script>a = 1</scr'+'ipt>')
      // TODO deterministic? Firefox and Chromium tests have passed.
      //assert_eq(a, 1)
    </script>
    <script>
      // TODO deterministic? Firefox and Chromium tests have passed.
      //assert_eq(a, 1)
    </script>

<script>
  // #Selectors

    // #querySelectorAll

      // Select elements by CSS selector. Very powerful.

      // Not supported in IE7.

        document.write('<div class="querySelectorAll0"><div class="querySelectorAll1" data-0="querySelectorAll"></div></div>')
        assert_eq(document.querySelectorAll(".querySelectorAll0 > .querySelectorAll1")[0].getAttribute("data-0"), "querySelectorAll")

    // #getElementById

        document.write('<div id="getElementById" data-0="1"></div>')
        assert_eq(document.getElementById("getElementById").getAttribute("data-0"), "1")

    // #getElementsByClassName

      // Not implemented on IE8... Alternatives: http://stackoverflow.com/questions/3808808/how-to-get-element-by-class-in-javascript
      // So if you care about IE8, just use querySelectorAll or JQuery.

        document.write('<div class="getElementsByClassName0 getElementsByClassName1" data-0="1"></div>')
        assert_eq(document.getElementsByClassName("getElementsByClassName0")[0].getAttribute("data-0"), "1")

    // #getElementsByTagName

      // Some special cases have shortcuts for them:

        assert_eq(document.getElementsByTagName('body')[0], document.body)
        assert_eq(document.getElementsByTagName('head')[0], document.head)

  // #DOM

    // #nodeType

      //- 1 : ELEMENT_NODE
      //- 2 : ATTRIBUTE_NODE
      //- 3 : TEXT_NODE
      //- 4 : CDATA_SECTION_NODE
      //- 5 : ENTITY_REFERENCE_NODE
      //- 6 : ENTITY_NODE
      //- 7 : PROCESSING_INSTRUCTION_NODE
      //- 8 : COMMENT_NODE
      //- 9 : DOCUMENT_NODE
      //- 10: DOCUMENT_TYPE_NODE
      //- 11: DOCUMENT_FRAGMENT_NODE
      //- 12: NOTATION_NODE

        document.write('<div id="nodeType">a<div>b</div>c</div>')
        var parent = document.getElementById('nodeType')
        assert_eq(parent.nodeType, 1)
        assert_eq(parent.childNodes[0].nodeType, 3)

    // #tagName

        document.write('<div id="tagName"></div>')
        assert_eq(document.getElementById('tagName').tagName, 'DIV')

    // #nodeValue #innerHTML

        document.write('<div id="nodeValue">a<i>b</i>c</div>')
        assert_eq(document.getElementById('nodeValue').firstChild.nodeValue, 'a')
        assert_eq(document.getElementById('nodeValue').innerHTML,            'a<i>b</i>c')

      // *Don't* do innerHTML += innerHTML + 'something' unless you are sure it is only a string.

      // Otherwise, this would destroy events associated to elements in the innerHTML.

    // #outerHTML

      // Includes the tags. Less support but increasing.

        document.write('<div id="nodeValue">a<i>b</i>c</div>')
        assert_eq(document.getElementById('nodeValue').outerHTML, '<div id="nodeValue">a<i>b</i>c</div>')

    // #children #firstElementChild #childnodes #firstChild #lastChild

        document.write('<div id="children">a<i>b</i>c</div>')

      // Children and firstElementChild: only elements, no text.

        assert_eq(document.getElementById('children').children[0].innerHTML,       'b')
        assert_eq(document.getElementById('children').firstElementChild.innerHTML, 'b')

      // childNodes and firstChild: include text.

        assert_eq(document.getElementById('children').firstChild.nodeValue,    'a')
        assert_eq(document.getElementById('children').childNodes[0].nodeValue, 'a')
        assert_eq(document.getElementById('children').lastChild.nodeValue,     'c')

    // #parentNode #nextSibling #nextElementSibling

        document.write('<div id="parentNode">a<i>b</i>c<i>d</i>e</div>')
        var firstI = document.getElementById('parentNode').children[0]
        assert_eq(firstI.parentNode.tagName, 'DIV')
        assert_eq(firstI.previousSibling.nodeValue, 'a')
        assert_eq(firstI.previousElementSibling, null)
        assert_eq(firstI.nextSibling.nodeValue, 'c')
        assert_eq(firstI.nextElementSibling.innerHTML, 'd')

    // #insertAdjacentHTML

      // Insert string before or after tag.

        document.write('<div>a<span id="insertAdjacentHTML">b</span>c</div>')
        var inner = document.getElementById('insertAdjacentHTML')
        inner.insertAdjacentHTML('beforeBegin', ' <b>beforeBegin</b> ')
        inner.insertAdjacentHTML('afterBegin',  ' afterBegin ')
        inner.insertAdjacentHTML('beforeEnd',   ' beforeEnd ')
        inner.insertAdjacentHTML('afterEnd',    ' <b>afterEnd</b> ')

    // #insertBefore

      // Insert an element before another.

      // Must work with elements: cannot insert string directly. Consider `insertAdjacentHTML` for that.

      // TODO what happens when element exists already? Copy?

        document.write('<div id="insertBefore">a<i>b</i>c</div>')
        var insertBefore = document.getElementById('insertBefore')
        var insertBeforeI = insertBefore.children[0]
        var divD = document.createElement('div');
        divD.appendChild(document.createTextNode('d'));
        insertBefore.insertBefore(divD, insertBeforeI)
        assert_eq(insertBeforeI.previousElementSibling.innerHTML, 'd')

      // #insertAfter

        // Does not exist, but easily defined with `insertBefore`.

        //http://stackoverflow.com/questions/4793604/how-to-do-insert-after-in-javascript-without-using-a-library

    // #getAttribute

      document.write('<div id="getAttribute">a<i>b</i>c<i>d</i>e</div>')
      assert_eq(document.getElementById('getAttribute').getAttribute('id'), 'getAttribute')

    // #style #CSS

      // Get and set CSS attributes.

      document.write('<div id="style" style="background-color:green; color:blue;">#style</div>')
      document.getElementById('style').style.backgroundColor = 'red'

    // #currentScript

      // Get the current script element.

        assert_eq(document.currentScript.parentNode, document.body)

    // #textarea #onkeypress

      document.write(
        '<h2>#textarea</h2>' +
        '<textarea id="textarea" onkeypress="textarea_func();">default</textarea>' +
        '<div id="textarea-value">Textarea value = <span></span></div>'
      )
      var textarea = document.getElementById('textarea')
      var textarea_value_holder = document.getElementById('textarea-value').lastElementChild
      function textarea_func() {
        textarea_value_holder.innerHTML = textarea.value
      }
      textarea_func()

      // #onchange

        // Value of input element changed.

    /*
    #canvas

      The HTML canvas element was made to be drawn with Javascript and destroy Flash.
    */

      document.write(
        '<h2>#canvas</h2>' +
        '<canvas id="canvas" width="200" height="100" style="border:1px solid black;"></canvas>' +
        '<div onclick="canvas_onclick()" class="border">canvas_onclick. Click me!</div>'
      )
      function canvas_onclick() {
        var b_canvas = document.getElementById("canvas");
        var b_context = b_canvas.getContext("2d");
        b_context.fillRect(50, 25, 150, 100);
      }

  // #ready

    // Event called when the document finished loading.

    // Necessary if you have a script that comes before the elements it will act on.

    // Not necessary if your script comes after the elements it acts on:
    // <http://stackoverflow.com/questions/4643990/jquery-is-document-ready-necessary>
    // Therefore, this should never be necessary, since all scripts should be put at the bottom of the page.

  // #cookies

    // A way of storing small data strings on user's computer hard disk

    // View all cookies on Firefox:

      //firefox chrome://browser/content/preferences/cookies.xul

    // Cookies are accessible through DOM

    // Cookies can be set/get only for current domain.

    // WARNING: some browsers may not keep cookies for local files (file://)
    // so these tests may fail. current firefox does keep the cookies.

    // Each browser stores its own cookies

    // #cookies without javascript

      // Cookies can also be set via headers using the `Set-Cookie` header key.

      // Cookies are automatically sent to servers by browsers via the `Cookie` header value.

      // Cookies are sent from servers to CGI scripts via the `HTTP_COOKIE` env var.

      // These are the most reliable methods, there is no need to use js for cookies.

    // #session cookies

      // A cookie based technique to maintain user logged in.

      // 1) username/password is sent to server encrypted in some way (HTTP Basic + SSL, POST + SSL)

      // 2) server authenticates, and creates a large random number, sotores it,
      // and sends it as a non persistent cookie that is an unique number

      // 3) whenever the user hits another URL, this large number is sent to server.
      // and user is logged in.

      //TODO: how to avoid getting the session highjacked?

    // #path

      // Cookies can be set only for the **current** path and its parents.

      // E.g.: in `www.abc.com/a/b.html`, the path is `a/a.html`.
      // so `a.html` can set cookies for `/`, `/a/` and `/a/a.html` from `/a/a.html`

      // If the location is a directory, then all subdirs can also get the cookies.
      // E.g.: cookies set for `/` can be seen on `/a/` and on `/b/`

    // #js interface

      // #set values

        // Browser parses the strings.

        // Set keys:

          document.cookie = "key=val;"
          document.cookie = "key=val2;"

        // Only `val2` is kept.

        // BAD:

          document.cookie = "key2=val2;key3=val3"

        // Only `key2` is set. Only a single key can be set at a time.

      // #get values

        // Not possible directly: must parse the `document.cookie` string.

      // #delete values

        // The simplest technique is to set a past expires date.

    // #properties

      // Are special key/value pairs that contain key metadata.

      // #expires

        // Previous key is deleted by browser at given UTC string date:

          var now = new Date()
          var later = now
          later.setMinutes(now.getMinutes() + 1)
          document.cookie += "keyExp=valExp;expires=" + later.toUTCString()

        // If expires is not given, then the cookie expires when the browser is closed!

        // It is not possible to make a cookie that never expires,
        // only one with a huge expiry date.

      // #path

        // Cookie path.

        // Defaults to current file/dir.

        // Can only be set for parent dirs of current path.

      // #safe

        // If set to exactly `= safe`, this cookie will only be sent over `https`, not `http`

          document.cookie = "keySafe=v;safe"

        // TODO confirm usage correct

      // #HttpOnly

        // Instructs server not to pass the cookie to CGI scripts.

        // This can increase security of session cookies.

        // <http://www.codinghorror.com/blog/2008/08/protecting-your-cookies-httponly.html>

          document.cookie = "keySafe=v;HttpOnly"

    // #higher level interface

      // The Javascript cookie interface is very low level and inconvenient.

      // jquery-cookie <https://github.com/carhartl/jquery-cookie> is on popular and convenient cookie interface based on JQuery.

      // #helpers

        // - c_name: string
        // - value: string
        // - exdays: integer. Number of days which will take for the cookie to expire.
        //
        function setCookie(c_name, value, exdays) {
          var exdate = new Date()
          exdate.setDate(exdate.getDate() + exdays)
          var c_value = escape(value) + ((exdays==null) ? "" : "; expires=" + exdate.toUTCString())
          document.cookie = c_name + "=" + c_value
        }

        // c_name: string
        // @return: null if not found, value if found
        //
        function getCookie(c_name) {
          var i, x, y, ARRcookies = document.cookie.split(";")
          for (i = 0; i < ARRcookies.length; i++) {
            x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="))
            y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1)
            x = x.replace(/^\s+|\s+$/g, "")
            if (x == c_name) {
              return unescape(y)
            }
          }
        }

        function delCookie(name, path, domain) {
          if (Get_Cookie(name))
            document.cookie=name+"="+((path) ? ";path="+path:"")+((domain)?";domain="+domain:"") +
                          ";expires=Thu, 01 Jan 1970 00:00:01 GMT"
        }

    document.write('<h2>cookies</h2>' + document.cookie + '<br>')
</script>

<h2>#events</h2>

  <p>Events are part of the DOM.</p>
  <p>Each event is attached to an element.</p>
  <p>Events propagate</p>
  <p>Like the rest of the DOM, it is a bit messy to find where events are defined.</p>
  <p>A good source is Firefox's documentation https://developer.mozilla.org/en-US/docs/Web/Reference/Events</p>
  <p>The major standards are:</p>
  <ul>
    <li>http://www.w3.org/TR/DOM-Level-3-Events/</li>
    <li>
      random points of HTML5 like
      http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end
      for `DOMContentLoaded`
    </li>
  </ul>

  <h3>#addEventListener</h3>

    <p>Allows to add an unlimited amount of handlers per event. Better choice than `on` events like `onload`.</p>
    <p>Can be used together with `on` events. TODO check.</p>
    <p>TODO do all events have a on version and an `addEventListener` one?</p>

    <h4>#useCapture parameter #capture vs #bubble</h4>

      <p>Determines the order in which listeners listen to the event.</p>
      <p>TODO exactly how, example</p>
      <p>A listener callback ends, the event is then sent to further listeners by default.</p>

    <h4>#stopPropagation</h4>

      <p>
        Prevent event from being listened on further listeners.
        http://stackoverflow.com/questions/4470417/how-do-i-consume-a-key-event-in-javascript-so-that-it-doesnt-propagate
      </p>
      <p>Only implemented in recent IE. Consider jQuery's `preventDefault` and/or `stopPropagation` if you care.</p>
      <p>TODO example</p>

    <h4>#dispatchEvent #Trigger events programmatically.</h4>

      <p>
        Programmatically trigger events.
        http://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
      </p>
      <p>TODO example</p>
      <p>
        TODO not possible to trigger standard events like click?
        http://stackoverflow.com/questions/809057/how-do-i-programmatically-click-on-an-element-in-firefox
      </p>
      <div id="dispatchEvent"></div>

  <h3>#document vs window events</h3>

    <p>
      `document` and `window` have different possible events:
      http://stackoverflow.com/questions/12045440/difference-between-document-addeventlistener-and-window-addeventlistener
    </p>

  <h3>Attach events to body</h3>

    <p>
      You cannot attach events to the `body` element form scripts in the head,
      because the body is not yet part of the DOM!
    </p>
    <p>Prefer to attach events to the `document` or `window` objects instead.</p>
    <div id="addEventListener">#FAIL</div>
    <script>
      document.body.addEventListener(
        'load',
        function() {
          document.getElementById('addEventListener').innerHTML = ''
        },
        true
      )
    </script>

  <h3>Useful events</h3>

    <h4>#load</h4>

      <p>
        Can only be used on `body` or elements that load remote sources such as
        `img`, `link` or remote `script` tags.
        Cannot be used on other elements such as `div`.
      </p>
      <p>
        Both window and document objects have this event:
        http://stackoverflow.com/questions/588040/window-onload-vs-document-onload>
        but `document`'s is probably more useful.
      </p>

    <h4>#DOMContentLoaded</h4>

      <p>HTML5 http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#the-end</p>
      <p>
        `DOMContentLoaded` vs `document.onload`:
        http://stackoverflow.com/questions/2414750/difference-between-domcontentloaded-and-load-events
        Former does not wait for external resources to load, later does.
      </p>
      <p>Used by jQuery's `$(document).ready` method where supported.</p>
      <div id="DOMContentLoaded"></div>
      <script>
        document.addEventListener(
          'DOMContentLoaded',
          function() {
            document.getElementById('DOMContentLoaded').innerHTML = 'DOMContentLoaded'
          },
          true
        )
      </script>
      <script>
        window.onload = function(){
          document.getElementById('window-onload').innerHTML = 'window-onload'
        }
      </script>
      <div id="onload"></div>
      <div id="window-onload"></div>
      <script>
        window.onload = function(){
          document.getElementById('window-onload').innerHTML = 'window-onload'
        }
      </script>

    <h4>#click</h4>

      <div class="border" id="onclick" onclick="onclick_func(event)" style="height:100px;">onclick. Click here.</div>
      <script>
        var onclick_func = function(even) {
          even.target.innerHTML += ' click'
        }
      </script>
      <div class="border" id="click" style="height:100px;">addEventListener click. Click here.</div>
      <script>
        function click(even) {
          even.target.innerHTML += ' click'
        }
        document.getElementById('click').addEventListener(
          'click',
          click,
          false
        )
      </script>
<script>
// #JSON

  // ES5. For greater portability, <https://github.com/douglascrockford/JSON-js/blob/master/json2.js>
  // is a common option through the CDN: <http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js>

  var json = '{"a":1, "b":"c"}'
  var obj = JSON.parse(json)
  assert_eq(obj.a, 1)
  assert_eq(obj.b, 'c')

// #XMLHttpRquest #ajax

  // Make a server request without reloading the current page.

    var xmlhttp = new XMLHttpRequest()

  // #open

    // Set basic request info. Does not send the request yet.

    // Open signature: `open(method,url,async)

      xmlhttp.open('GET',  'ajax/url', true)
      xmlhttp.open('GET',  'ajax/url?a=1&b=2', true)
      xmlhttp.open('POST', 'ajax/url', true)
      xmlhttp.open('POST', 'ajax/url', true)

    // Post data is set at `send`.

  // #setRequestHeader

    // Allows full control over the HTTP headers.

    // Many JS libraries add the following to the header:

      // xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest')

  /*
  #response #onreadystatechange

    Response should be used from a callback function on asynchronous mode.

    `onreadystatechange` callback is called every time the readyState property changes.

    Its possible values are:

    - 0: request not initialized
    - 1: server connection established
    - 2: request received
    - 3: processing request
    - 4: request finished and response is ready

    It is typical for the state to go through all of those states.

    TODO how does the server inform which state we are currently on?
  */

      xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {

          // #responseText

            // Field always present.

            // If the response is known to be plain text,
            // it should be retrieved via the `responseText` attribute.

              document.getElementById("myDiv").innerHTML = xmlhttp.responseText

          // #responseXML

            // Field only present if the response type is specified XML on the HTTP headers.

              //xmlDoc = xmlhttp.responseXML
              //x = xmlDoc.getElementsByTagName("ARTIST")
              //for (i = 0; i < x.length; i++) {
                //txt=txt + x[i].childNodes[0].nodeValue + "<br>"
              //}
        }
      }

  // #send

    // Send the request.

    // Can also send data for post requests:

      //xmlhttp.send()
      //xmlhttp.send("fname=Henry&lname=Ford")

  // #same origin policy #cross origin XMLHttpRequest.

    // For security reasons, browsers don't let you do Javascript HTTP requests by default
    // to different locations other than the current one, otherwise those sites might be able to obtain
    // your session cookies.

      //http://en.wikipedia.org/wiki/Same_origin_policy

    // A common symptom of this is getting a `xmlhttp.status == 0`.

/*
#use strict

  Puts current function on an interpreter mode that warns about common errors.

  http://stackoverflow.com/questions/1335851/what-does-use-strict-do-in-javascript-and-what-is-the-reasoning-behind-it
*/
</script>
</body>
</html>
